OOP concepts
-=================
Object-Oriented Programming (OOP)** is a programming based on the concept of objects, which can contain data and methods. 
The four main principles of OOP are
**Encapsulation, Inheritance, Polymorphism,** and **Abstraction**. 

### 1. **Encapsulation**
Encapsulation refers to the bundling of data (fields) and methods (functions) that operate on the data into a single unit, typically a class. 
It restricts direct access to some of the object's components and can prevent accidental interference or misuse.

- **Purpose**: 
Protects object integrity by preventing external code from directly modifying fields. 
It helps in maintaining control over how data is accessed or modified.
- **How**: By using access modifiers like `private`, `public`, and `protected`.

#### Example:
```java
public class Car {
    private String model;
    private int year;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }
}
```
Getters and setters method
==============================
In this example, the `model` and `year` fields are private, meaning they can only be accessed via the public getter and setter methods.
Getter and Setter methods control access to a class’s fields and provide flexibility, data validation, and encapsulation.
They ensure that fields are accessed in a controlled manner and can include additional logic such as validation, logging, or synchronization.
They allow for data hiding, read-only or write-only access, and maintain flexibility if internal data representation needs to change in the future.

what is differance b/w encapsulation and abstraction
============================================================
Encapsulation:
Encapsulation is used to secure the internal state of an object by restricting unauthorized access and modification.
It allows changes to the internal implementation without affecting external code that uses the class.
It provides data hiding by making fields private and exposing them through getter and setter methods.
Abstraction:
Abstraction is used to simplify complex systems by hiding unnecessary details and exposing only the essential information.
It allows developers to interact with objects without knowing their underlying implementation, making the system more user-friendly and less complex.

Key Differences:
Aspect	     Encapsulation	                                                              Abstraction
Definition	Bundles data and methods into a class and restricts direct access to fields.	Hides implementation details and shows only essential features.
           Purpose	Protects internal data and controls access.	                          Simplifies complexity by focusing on what an object does.
           Focus	Securing and controlling access to data.	                               Simplifying interaction by hiding details.
Implementation	Achieved using private fields and public getters/setters.              	Achieved using abstract classes, interfaces, and abstract methods.
Visibility	Controlled via access modifiers (private, public, etc.).	                  Hides internal logic; user only sees relevant features.

what is data hiding
=====================
Data hiding is a concept in (OOP) where internal details of a class (such as data members or fields) are hidden from external access. 
This ensures that the internal state of an object cannot be directly accessed or modified by external code. 
Instead, access is provided through controlled means such as getters and setters or other public methods.


### 2. **Inheritance**
Is_A relation(Inheritance)
============================
Inheritance represents the IS-A relationship which is also known as a parent-child relationship.
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. 
It provides code reusability. It is used to achieve runtime polymorphism
 .
 When you inherit from an existing class, you can reuse methods and fields of the parent class.

• By using extends keyword  we can implements is-a relationship

 there can be three types of inheritance in java:
=======================================================
single inheritance
-----------------
When a class inherits another class, it is known as a single inheritance.

multilevel 
--------------
When there is a chain of inheritance, it is known as multilevel inheritance.

hierarchical.
-------------------
When two or more classes inherits a single class, it is known as hierarchical inheritance.

multiple and hybrid inheritance is supported through interface only.

why multiple inheritance is supported by the java
----------------------------------------------------------
To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. 
If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

- **Purpose**: Promotes code reuse and establishes a natural hierarchy between classes.
- **How**: Use the `extends` keyword in Java to create a child class that inherits from a parent class.

#### Example:
```java
public class Vehicle {
    public void start() {
        System.out.println("Vehicle is starting");
    }
}

public class Car extends Vehicle {
    public void honk() {
        System.out.println("Car is honking");
    }
}
```

In this case, the `Car` class inherits the `start` method from the `Vehicle` class and adds its own method `honk`.

---

### 3. **Polymorphism**

Polymorphism in Java is a concept by which we can perform a single action in different ways.

There are two types of polymorphism in Java: 
compile-time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.
Overloading
===============
Two methods are said to be overloaded if method names are same but argument as different is called oveloading
 **Compile-time polymorphism (Method Overloading)**: When multiple methods have the same name but different parameter lists.
public class Calculator {
    // Overloaded method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method to add two double values
    public double add(double a, double b) {
        return a + b;
    }
}

Overriding
==============
If method names and arguments must be matched  i.e method signature must be matched is called overriding.
- **Run-time polymorphism (Method Overriding)**: When a subclass provides a specific implementation of a method that is already defined in its superclass.

class Animal {
    // Method to be overridden
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal reference, Animal object
        Animal myDog = new Dog();        // Animal reference, Dog object

        myAnimal.sound();  // Calls Animal's sound method
        myDog.sound();     // Calls Dog's sound method (overridden method)
    }
}

Polymorphism allows objects of different classes to be treated as objects of a common superclass. There are two types of polymorphism:


- **Purpose**: Allows a single interface to be used for a general class of actions, making the system more flexible and scalable.

#### Example (Method Overriding):
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // Polymorphism
        animal.sound();  // Output: Dog barks
    }
}
```

In this example, the `sound()` method is overridden in the `Dog` class. Although the object is of type `Animal`, the actual method invoked is from the `Dog` class, demonstrating runtime polymorphism.

---

### 4. **Abstraction**
Abstraction is the concept of hiding the implementation details and exposing only the essential features of an object.
It allows you to focus on what an object does rather than how it does it.

- **Purpose**: Simplifies complex systems by providing only the necessary details to the user.
- **How**: In Java, abstraction can be achieved using abstract classes or interfaces.

#### Example (Interface):
```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Cat meows");
    }
}
```

In this example, both `Dog` and `Cat` implement the `Animal` interface and provide their own implementations of the `sound()` method. The user doesn't need to know how the `sound()` method works, just that it exists.

Diff b/w abstrcat class and interface
======================================

1. Purpose
Abstract Class: Used to represent a base class that other classes can inherit from. It can provide some default behavior (implemented methods) while leaving 
some methods abstract for subclasses to implement.
Interface: Used to represent a contract that a class must adhere to. It’s purely about defining the behavior that implementing classes must provide,
without providing any implementation (until Java 8 introduced default methods).

2. Syntax
Abstract Class: Declared with the abstract keyword. It can have both abstract methods (without implementation) and concrete methods (with implementation).

abstract class Animal {
    abstract void sound(); // Abstract method
    void eat() { // Concrete method
        System.out.println("This animal eats");
    }
}
Interface: Declared with the interface keyword. It can have abstract methods , default methods (with implementation, introduced in Java 8), and static methods.
interface Animal {
    void sound(); // Abstract method
    default void eat() { // Default method (Java 8+)
        System.out.println("This animal eats");
    }
}

3. Method Implementation
Abstract Class: Can have both abstract and concrete methods. Subclasses can inherit and use the concrete methods or override them.
Interface: Prior to Java 8, all methods were implicitly abstract. From Java 8 onward, interfaces can have default and static methods with implementations.

4. Inheritance
Abstract Class: A class can inherit from only one abstract class (single inheritance).
Interface: A class can implement multiple interfaces (multiple inheritance of type).

5. Fields/Variables
Abstract Class: Can have instance variables (fields) and can define methods to manipulate these variables.

Interface: Can only have public, static, and final variables (essentially constants). Instance variables are not allowed.
abstract class Animal {
    int age; // Instance variable
}

interface Animal {
    int AGE = 10; // Constant (implicitly public, static, and final)
}
6. Constructors
Abstract Class: Can have constructors. These constructors are called when a subclass is instantiated.
Interface: Cannot have constructors because interfaces cannot be instantiated.

7. Access Modifiers
Abstract Class: Can have methods with any access modifier (public, protected, private, or default).
Interface: Methods are implicitly public. From Java 9 onward, private methods are allowed within interfaces to share code between default methods.

8. When to Use
Abstract Class:
Use when classes share a common base of code (fields or methods).
Use when you want to provide some common functionality that can be inherited by subclasses.
Use when you expect future classes to have many common methods or fields.

Interface:
Use to define a contract that multiple classes can implement.
Use when you want to achieve multiple inheritance in Java.
Use when you want to provide flexibility for unrelated classes to implement the same set of behaviors.

9. Example Use Cases
Abstract Class: A Vehicle abstract class where all vehicles have common properties (like speed, fuel) and behaviors (like startEngine()), but startEngine() may be implemented differently in subclasses (Car, Bike).

Interface: A Flyable interface for classes that can fly (Bird, Airplane), where each class implements its own version of the fly() method.

Marker interface
==================
If an interface wont contains any method & by implementing that interface if our object will get ability such type of interface are called marker interface.
An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, random access method.etc.

They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

By implementing seriazable interface we can send object across the n/w and we can save state of object to a file this extra ability is provided through seriazable interface

By implemeting clonable interface our object will be in position to provide exactly duplicate object

As marker interface interface wont contain method them jvm is responsible for that to reduce complexity of program
We can create our own marker interfface but customization of jvm required.

Collection
Set 
Hashset
hashtable

List
is datastructor in collection whenere we want to represent group of individual object as single entity where duplicates are allowed and
insertion order is preserved then we can go for LIST .

diff b/w Arraylist and linkedlist

1. Underlying Data Structure:
ArrayList:
Internally, ArrayList is backed by a dynamic array (resizable array).
Elements are stored in a contiguous block of memory.

LinkedList:
Internally, LinkedList is implemented as a doubly linked list.
Each element (node) contains a reference to both the next and the previous node, making it a chain of elements connected via pointers.

2. Performance:
Access (Get/Set):
ArrayList:
Accessing elements is fast because it allows random access (constant-time access) via the index.
Time complexity for access is O(1).
Example: arrayList.get(index) is very efficient.

LinkedList:
Accessing elements is slower because it requires traversing the list from the beginning or end to reach the desired element.
Time complexity for access is O(n) for getting or setting an element by index.
Example: linkedList.get(index) will take longer if the index is near the end.

Insertion and Deletion:
ArrayList:
Inserting or deleting elements (especially in the middle or at the beginning) is slower because it requires shifting elements to make space or fill gaps.
Time complexity for insertion/deletion is O(n) in the worst case.
Insertion at the end of the ArrayList is generally O(1), unless the array needs to resize.

LinkedList:
Inserting or deleting elements is faster in a LinkedList, especially at the beginning or in the middle, because it only requires updating the links (pointers) between nodes.
Time complexity for insertion/deletion at the beginning or end is O(1).
Inserting in the middle of the list takes O(n) to traverse but O(1) to modify links.

Resizing:
ArrayList:
When the internal array fills up, ArrayList dynamically resizes itself (usually by doubling its size). This involves creating a new array and copying all elements, which takes time.

LinkedList:
LinkedList does not need resizing because it is not array-based. It just creates new nodes as needed, making it more efficient for frequently growing or shrinking lists.

3. Memory Usage:
ArrayList:
ArrayList requires less memory overhead because it only stores the data and an index pointer. However, when it resizes, it may allocate more memory than required (extra space for future elements).

LinkedList:
LinkedList uses more memory because, in addition to storing the data, it also stores two pointers (references) for each node (next and previous), which increases memory usage.

4. Use Cases:
ArrayList:
Best when you need fast access to elements using indexes.
Suitable for scenarios where elements are primarily added at the end, and random access is required.
Example: Storing frequently accessed data, like a list of cities where you need to access elements by index.

LinkedList:
Best when you need frequent insertions or deletions at the beginning or middle of the list.
Suitable for scenarios where the size of the list changes frequently and you don't need random access.
Example: Implementing a queue or stack, where elements are added/removed from the front or end frequently.

5. Implementation in Java:
ArrayList:
import java.util.ArrayList;

ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("Apple");
arrayList.add("Banana");
System.out.println(arrayList.get(1)); // Accessing element is fast

LinkedList:
java
Copy code
import java.util.LinkedList;

LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
linkedList.addFirst("Orange"); // Efficient insertion at the beginning
System.out.println(linkedList.get(1)); // Accessing element is slower

Map
=====
Hashmap implementation,how it function

Concurrenthashmap-its sychronous or asyncronous
Concurrenthashmapmodificationexception




