OOP concepts
-=================
Object-Oriented Programming (OOP)** is a programming based on the concept of objects, which can contain data and methods. 
The four main principles of OOP are
**Encapsulation, Inheritance, Polymorphism,** and **Abstraction**. 

### 1. **Encapsulation**
Encapsulation refers to the bundling of data (fields) and methods (functions) that operate on the data into a single unit, typically a class. 
It restricts direct access to some of the object's components and can prevent accidental interference or misuse.

- **Purpose**: 
Protects object integrity by preventing external code from directly modifying fields. 
It helps in maintaining control over how data is accessed or modified.
- **How**: By using access modifiers like `private`, `public`, and `protected`.

#### Example:
```java
public class Car {
    private String model;
    private int year;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }
}
```
Getters and setters method
==============================
In this example, the `model` and `year` fields are private, meaning they can only be accessed via the public getter and setter methods.
Getter and Setter methods control access to a class’s fields and provide flexibility, data validation, and encapsulation.
They ensure that fields are accessed in a controlled manner and can include additional logic such as validation, logging, or synchronization.
They allow for data hiding, read-only or write-only access, and maintain flexibility if internal data representation needs to change in the future.

what is differance b/w encapsulation and abstraction
============================================================
Encapsulation:
Encapsulation is used to secure the internal state of an object by restricting unauthorized access and modification.
It allows changes to the internal implementation without affecting external code that uses the class.
It provides data hiding by making fields private and exposing them through getter and setter methods.
Abstraction:
Abstraction is used to simplify complex systems by hiding unnecessary details and exposing only the essential information.
It allows developers to interact with objects without knowing their underlying implementation, making the system more user-friendly and less complex.

Key Differences:
Aspect	     Encapsulation	                                                              Abstraction
Definition	Bundles data and methods into a class and restricts direct access to fields.	Hides implementation details and shows only essential features.
           Purpose	Protects internal data and controls access.	                          Simplifies complexity by focusing on what an object does.
           Focus	Securing and controlling access to data.	                               Simplifying interaction by hiding details.
Implementation	Achieved using private fields and public getters/setters.              	Achieved using abstract classes, interfaces, and abstract methods.
Visibility	Controlled via access modifiers (private, public, etc.).	                  Hides internal logic; user only sees relevant features.

what is data hiding
=====================
Data hiding is a concept in (OOP) where internal details of a class (such as data members or fields) are hidden from external access. 
This ensures that the internal state of an object cannot be directly accessed or modified by external code. 
Instead, access is provided through controlled means such as getters and setters or other public methods.


### 2. **Inheritance**
Is_A relation(Inheritance)
============================
Inheritance represents the IS-A relationship which is also known as a parent-child relationship.
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. 
It provides code reusability. It is used to achieve runtime polymorphism
 .
 When you inherit from an existing class, you can reuse methods and fields of the parent class.

• By using extends keyword  we can implements is-a relationship

 there can be three types of inheritance in java:
=======================================================
single inheritance
-----------------
When a class inherits another class, it is known as a single inheritance.

multilevel 
--------------
When there is a chain of inheritance, it is known as multilevel inheritance.

hierarchical.
-------------------
When two or more classes inherits a single class, it is known as hierarchical inheritance.

multiple and hybrid inheritance is supported through interface only.

why multiple inheritance is supported by the java
----------------------------------------------------------
To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. 
If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

- **Purpose**: Promotes code reuse and establishes a natural hierarchy between classes.
- **How**: Use the `extends` keyword in Java to create a child class that inherits from a parent class.

#### Example:
```java
public class Vehicle {
    public void start() {
        System.out.println("Vehicle is starting");
    }
}

public class Car extends Vehicle {
    public void honk() {
        System.out.println("Car is honking");
    }
}
```

In this case, the `Car` class inherits the `start` method from the `Vehicle` class and adds its own method `honk`.

---

### 3. **Polymorphism**

Polymorphism in Java is a concept by which we can perform a single action in different ways.

There are two types of polymorphism in Java: 
compile-time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.
Overloading
===============
Two methods are said to be overloaded if method names are same but argument as different is called oveloading
 **Compile-time polymorphism (Method Overloading)**: When multiple methods have the same name but different parameter lists.
public class Calculator {
    // Overloaded method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method to add two double values
    public double add(double a, double b) {
        return a + b;
    }
}

Overriding
==============
If method names and arguments must be matched  i.e method signature must be matched is called overriding.
- **Run-time polymorphism (Method Overriding)**: When a subclass provides a specific implementation of a method that is already defined in its superclass.

class Animal {
    // Method to be overridden
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal reference, Animal object
        Animal myDog = new Dog();        // Animal reference, Dog object

        myAnimal.sound();  // Calls Animal's sound method
        myDog.sound();     // Calls Dog's sound method (overridden method)
    }
}

Polymorphism allows objects of different classes to be treated as objects of a common superclass. There are two types of polymorphism:


- **Purpose**: Allows a single interface to be used for a general class of actions, making the system more flexible and scalable.

#### Example (Method Overriding):
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // Polymorphism
        animal.sound();  // Output: Dog barks
    }
}
```

In this example, the `sound()` method is overridden in the `Dog` class. Although the object is of type `Animal`, the actual method invoked is from the `Dog` class, demonstrating runtime polymorphism.

---

### 4. **Abstraction**
Abstraction is the concept of hiding the implementation details and exposing only the essential features of an object.
It allows you to focus on what an object does rather than how it does it.

- **Purpose**: Simplifies complex systems by providing only the necessary details to the user.
- **How**: In Java, abstraction can be achieved using abstract classes or interfaces.

#### Example (Interface):
```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Cat meows");
    }
}
```

In this example, both `Dog` and `Cat` implement the `Animal` interface and provide their own implementations of the `sound()` method. The user doesn't need to know how the `sound()` method works, just that it exists.

Diff b/w abstrcat class and interface
======================================

1. Purpose
Abstract Class: Used to represent a base class that other classes can inherit from. It can provide some default behavior (implemented methods) while leaving 
some methods abstract for subclasses to implement.
Interface: Used to represent a contract that a class must adhere to. It’s purely about defining the behavior that implementing classes must provide,
without providing any implementation (until Java 8 introduced default methods).

2. Syntax
Abstract Class: Declared with the abstract keyword. It can have both abstract methods (without implementation) and concrete methods (with implementation).

abstract class Animal {
    abstract void sound(); // Abstract method
    void eat() { // Concrete method
        System.out.println("This animal eats");
    }
}
Interface: Declared with the interface keyword. It can have abstract methods , default methods (with implementation, introduced in Java 8), and static methods.
interface Animal {
    void sound(); // Abstract method
    default void eat() { // Default method (Java 8+)
        System.out.println("This animal eats");
    }
}

3. Method Implementation
Abstract Class: Can have both abstract and concrete methods. Subclasses can inherit and use the concrete methods or override them.
Interface: Prior to Java 8, all methods were implicitly abstract. From Java 8 onward, interfaces can have default and static methods with implementations.

4. Inheritance
Abstract Class: A class can inherit from only one abstract class (single inheritance).
Interface: A class can implement multiple interfaces (multiple inheritance of type).

5. Fields/Variables
Abstract Class: Can have instance variables (fields) and can define methods to manipulate these variables.

Interface: Can only have public, static, and final variables (essentially constants). Instance variables are not allowed.
abstract class Animal {
    int age; // Instance variable
}

interface Animal {
    int AGE = 10; // Constant (implicitly public, static, and final)
}
6. Constructors
Abstract Class: Can have constructors. These constructors are called when a subclass is instantiated.
Interface: Cannot have constructors because interfaces cannot be instantiated.

7. Access Modifiers
Abstract Class: Can have methods with any access modifier (public, protected, private, or default).
Interface: Methods are implicitly public. From Java 9 onward, private methods are allowed within interfaces to share code between default methods.

8. When to Use
Abstract Class:
Use when classes share a common base of code (fields or methods).
Use when you want to provide some common functionality that can be inherited by subclasses.
Use when you expect future classes to have many common methods or fields.

Interface:
Use to define a contract that multiple classes can implement.
Use when you want to achieve multiple inheritance in Java.
Use when you want to provide flexibility for unrelated classes to implement the same set of behaviors.

9. Example Use Cases
Abstract Class: A Vehicle abstract class where all vehicles have common properties (like speed, fuel) and behaviors (like startEngine()), but startEngine() may be implemented differently in subclasses (Car, Bike).

Interface: A Flyable interface for classes that can fly (Bird, Airplane), where each class implements its own version of the fly() method.

Marker interface
==================
If an interface wont contains any method & by implementing that interface if our object will get ability such type of interface are called marker interface.
An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, random access method.etc.

They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

By implementing seriazable interface we can send object across the n/w and we can save state of object to a file this extra ability is provided through seriazable interface

By implemeting clonable interface our object will be in position to provide exactly duplicate object

As marker interface interface wont contain method them jvm is responsible for that to reduce complexity of program
We can create our own marker interfface but customization of jvm required.

Collection
Set 
Hashset
hashtable

List
is datastructor in collection whenere we want to represent group of individual object as single entity where duplicates are allowed and
insertion order is preserved then we can go for LIST .

diff b/w Arraylist and linkedlist

1. Underlying Data Structure:
ArrayList:
Internally, ArrayList is backed by a dynamic array (resizable array).
Elements are stored in a contiguous block of memory.

LinkedList:
Internally, LinkedList is implemented as a doubly linked list.
Each element (node) contains a reference to both the next and the previous node, making it a chain of elements connected via pointers.

2. Performance:
Access (Get/Set):
ArrayList:
Accessing elements is fast because it allows random access (constant-time access) via the index.
Time complexity for access is O(1).
Example: arrayList.get(index) is very efficient.

LinkedList:
Accessing elements is slower because it requires traversing the list from the beginning or end to reach the desired element.
Time complexity for access is O(n) for getting or setting an element by index.
Example: linkedList.get(index) will take longer if the index is near the end.

Insertion and Deletion:
ArrayList:
Inserting or deleting elements (especially in the middle or at the beginning) is slower because it requires shifting elements to make space or fill gaps.
Time complexity for insertion/deletion is O(n) in the worst case.
Insertion at the end of the ArrayList is generally O(1), unless the array needs to resize.

LinkedList:
Inserting or deleting elements is faster in a LinkedList, especially at the beginning or in the middle, because it only requires updating the links (pointers) between nodes.
Time complexity for insertion/deletion at the beginning or end is O(1).
Inserting in the middle of the list takes O(n) to traverse but O(1) to modify links.

Resizing:
ArrayList:
When the internal array fills up, ArrayList dynamically resizes itself (usually by doubling its size). This involves creating a new array and copying all elements, which takes time.

LinkedList:
LinkedList does not need resizing because it is not array-based. It just creates new nodes as needed, making it more efficient for frequently growing or shrinking lists.

3. Memory Usage:
ArrayList:
ArrayList requires less memory overhead because it only stores the data and an index pointer. However, when it resizes, it may allocate more memory than required (extra space for future elements).

LinkedList:
LinkedList uses more memory because, in addition to storing the data, it also stores two pointers (references) for each node (next and previous), which increases memory usage.

4. Use Cases:
ArrayList:
Best when you need fast access to elements using indexes.
Suitable for scenarios where elements are primarily added at the end, and random access is required.
Example: Storing frequently accessed data, like a list of cities where you need to access elements by index.

LinkedList:
Best when you need frequent insertions or deletions at the beginning or middle of the list.
Suitable for scenarios where the size of the list changes frequently and you don't need random access.
Example: Implementing a queue or stack, where elements are added/removed from the front or end frequently.

5. Implementation in Java:
ArrayList:
import java.util.ArrayList;

ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("Apple");
arrayList.add("Banana");
System.out.println(arrayList.get(1)); // Accessing element is fast

LinkedList:
java
Copy code
import java.util.LinkedList;

LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
linkedList.addFirst("Orange"); // Efficient insertion at the beginning
System.out.println(linkedList.get(1)); // Accessing element is slower

Map
=====
Hashmap implementation,how it function
Intenal working of hashmap and implementation
---------------------------------------------------
### Internal Working of a HashMap in Java

A **HashMap** in Java is a part of the `java.util` package and is one of the most commonly used data structures. It allows storing key-value pairs, where each key is unique.
The key is used to retrieve the value stored in the map. The main concept behind a HashMap is the use of a hash table, which allows for fast access to the data.

1. Hash Function
   - When a key-value pair is inserted into the HashMap, the key is passed through a hash function. The hash function generates an integer (hash code) that represents the key.
   - The hash code is then used to determine the index in the array (bucket) where the entry should be stored.

2. **Index Calculation**
   - The hash code is transformed into an index     
 3. **Collision Handling**
   - A collision occurs when two different keys produce the same index. 
HashMap handles collisions using a technique called **Separate Chaining
   - **Separate Chaining:** Each bucket in the array points to a linked list of entries that share the same index. 
When a collision occurs, the new entry is added to the linked list.

4. **Rehashing**
   - When the load factor (ratio of number of elements to the array size) exceeds a threshold (usually 0.75), the HashMap increases its array size (doubles it) and rehashes all entries.
   - Rehashing involves recalculating the index for each entry and moving it to the new array.
5. **Retrieving Values**
   - To retrieve a value, the key is passed through the same hash function to find the index.
   - The HashMap then traverses the linked list at that index to find the entry with the matching key.


Java Implementation of a Simple HashMap

public class HashMapImplementation<K, V> {
    private static final int INITIAL_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
 
    private Node<K, V>[] table;
    private int size = 0;
 
    public HashMapImplementation() {
        table = new Node[INITIAL_CAPACITY];
    }
 
    static class Node<K, V> {
        final K key;
        V value;
        Node<K, V> next;
 
        Node(K key, V value, Node<K, V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
 
    public void put(K key, V value) {
        int index = indexFor(key.hashCode(), table.length);
        Node<K, V> current = table[index];
        for (Node<K, V> node = current; node != null; node = node.next) {
            if (node.key.equals(key)) {
                node.value = value;
                return;
            }
        }
        table[index] = new Node<>(key, value, current);
        size++;
        if (size > table.length * LOAD_FACTOR) {
            resize(2 * table.length);
        }
    }
 
    public V get(K key) {
        int index = indexFor(key.hashCode(), table.length);
        Node<K, V> node = table[index];
        while (node != null) {
            if (node.key.equals(key)) {
                return node.value;
            }
            node = node.next;
        }
        return null;
    }
 
    private int indexFor(int hashCode, int length) {
        return hashCode & (length - 1);
    }
 
    private void resize(int newCapacity) {
        Node<K, V>[] oldTable = table;
        table = new Node[newCapacity];
        size = 0;
        for (Node<K, V> head : oldTable) {
            while (head != null) {
                put(head.key, head.value);
                head = head.next;
            }
        }
    }
}
Concurrenthashmap-its sychronous or asyncronous
ConcurrentHashMap is a class in Java from the java.util.concurrent package that provides a thread-safe and high-performance implementation of a hash table. It is designed to allow concurrent access to multiple threads without requiring the use of external synchronization mechanisms like manually locking the entire map. This makes it ideal for use in multithreaded environments where read and write operations are performed frequently by different threads.

Key Features of ConcurrentHashMap:
Thread-Safety:

ConcurrentHashMap allows concurrent read and write operations by dividing the map into segments (or buckets). Multiple threads can read and write to different segments concurrently without locking the entire map.
It avoids performance bottlenecks typically associated with fully synchronized collections like Hashtable or Collections.synchronizedMap().
No Null Keys or Values:

Unlike HashMap, ConcurrentHashMap does not allow null keys or values. If you try to insert a null key or value, it throws a NullPointerException.
Segmented Locking (Optimized Locking Mechanism):

Internally, ConcurrentHashMap uses a technique called segment locking (or bucket locking). Instead of locking the entire map, it only locks specific segments (or buckets) when modifying them, allowing higher concurrency.
Multiple threads can update the map simultaneously as long as they operate on different segments.
High Performance:

The map supports a high degree of concurrency, making it much faster than Hashtable or synchronizedMap when dealing with large data sets or frequent updates.
Read operations are generally non-blocking, which improves performance in read-heavy scenarios.
Atomic Operations:

ConcurrentHashMap provides methods for atomic operations like putIfAbsent(), remove(), replace(), which allow certain operations to be done in a thread-safe manner without needing explicit locks.
Weak Consistency:

Iterators returned by ConcurrentHashMap are weakly consistent. This means that they do not throw ConcurrentModificationException if the map is modified during iteration. Instead, they reflect the state of the map at the time they were created and may reflect some updates made after their creation.
However, they do not guarantee to show all updates made after the iterator was created.

When to Use ConcurrentHashMap:
When you need a thread-safe map and want to avoid performance bottlenecks caused by full synchronization in a multi-threaded environment.
When you need a map for read-heavy workloads, but occasional updates are necessary.
When you need fine-grained locking for frequent updates without affecting the performance of other operations.

Key Differences Between HashMap, Hashtable, and ConcurrentHashMap:
======================================================================
Feature	HashMap	             Hashtable	                                     ConcurrentHashMap
Thread-Safety	Not thread-safe	Thread-safe (synchronized)	Thread-safe with high concurrency
Null Keys/Values	Allows null keys/values	Does not allow null keys/values	Does not allow null keys/values
Performance	Fast, but not safe for concurrency	Slower due to full synchronization	Better performance in multithreaded scenarios
Locking Mechanism	No locking	Locks the entire map	Fine-grained locking on segments/buckets
Iterator Consistency	Fail-fast	Fail-fast	Weakly consistent

Concurrenthashmapmodificationexception
concurrentModificationEXaception
----------------------
A ConcurrentModificationException in Java is thrown when a collection (e.g., ArrayList, HashMap) is modified while being iterated over 
using methods like Iterator or enhanced for loop. This exception is typically encountered when you modify the collection directly 
(e.g., using add, remove, or put methods) during iteration.
7)concurrentModificatiobRxception
====================================
List <Integer> list=new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
try{
Iterator <Integer> iterator=new Iterator<>();
Integer value=iterator.next();
while(iterator.hashNext){
if(value%2==0){
list.remove(list);
} }
catch(concurrentModificatiobRxception e){
Systrm.out.println("concurrentModificatiobRxception caugght"+e);
Sysout("list after modification attempt "+ list);

}
}

what are java 8 features
functinonal interface
A functional interface in Java is an interface that contains exactly one abstract method. These interfaces are meant to represent a single function or operation,
which can be implemented or passed around like a function pointer or lambda expression. 
Functional interfaces are a key component in enabling lambda expressions and method references in Java, starting with Java 8.
Single Abstract Method (SAM):

A functional interface has exactly one abstract method. This single method defines the interface's functionality.
The method can be implemented using a lambda expression or a method reference.

@FunctionalInterface Annotation:
While not mandatory, it's common to annotate functional interfaces with the @FunctionalInterface annotation. This helps the compiler ensure that the interface conforms to the functional interface specification (i.e., it contains only one abstract method).
If the interface has more than one abstract method, the compiler will throw an error.

Default and Static Methods:
Functional interfaces can have default and static methods in addition to the single abstract method.
These do not count as abstract methods and do not affect the functional nature of the interface.

streams(interme)
IntStream is a specialized stream in Java. It is designed to work specifically with primitive int values, avoiding the overhead of autoboxing that occurs when using the regular Stream<Integer> for integer streams.

The IntStream provides several useful methods for processing sequences of int values in a functional programming style, similar to how the regular 
Stream works with objects. It supports a variety of operations such as filtering, mapping, reducing, sorting, etc., all tailored to int primitives.

filter and map diff
Key Differences
Functionality:
filter: Selects elements based on a condition. It removes elements that do not meet the criterion.
map: Transforms elements based on a function. It modifies each element to produce a new form.

Input and Output:
filter: Takes a Predicate<T> and returns a stream of elements that match the predicate.
map: Takes a Function<T, R> and returns a stream of elements that are the result of applying the function to each original element.

Usage in a Pipeline:
You often use filter before map in a stream pipeline to first reduce the number of elements and then transform the remaining elements.

consumer ,supplier
========================
Key Differences
Purpose
Consumer: Takes an input and performs an action without returning a result. It is used for operations that consume data.
Supplier: Provides a result without requiring any input. It is used for producing or generating values.
Method:

Consumer: accept(T t)
Supplier: get()
Use Cases:
Consumer: Typically used in scenarios where an action needs to be performed on an input (e.g., printing or updating values).
Supplier: Typically used in scenarios where values need to be provided or generated (e.g., factory methods or default values).

Functional Composition:
Consumer: Can be composed using andThen to perform sequential actions.
Supplier: Does not have built-in composition but can be combined with other functional interfaces in a broader context.

stream -optional
Key Characteristics of Optional:
Purpose:
To represent a value that might be present or absent, thus reducing the risk of NullPointerException.
To provide a more expressive way of handling cases where a value might be missing.

Common Methods:

isPresent(): Checks if a value is present.
ifPresent(Consumer<? super T> action): Executes a given action if the value is present.
get(): Retrieves the value if present, otherwise throws NoSuchElementException.
orElse(T other): Returns the value if present, otherwise returns the provided default value.

parallel stream
==================

In Java, parallel streams provide a way to process collections of data in parallel, leveraging multi-core processors to potentially speed up computations. The Streams API, introduced in Java 8, includes support for parallel streams, allowing for concurrent processing of elements.
Parallel Streams allow for concurrent processing of data using multiple threads, potentially improving performance for large datasets or computationally intensive tasks.
parallelStream() creates a parallel stream from a collection, and parallel() can be used to convert a sequential stream to parallel.

Key Concepts of Parallel Streams
Parallel vs. Sequential Streams:
sequential Stream: Processes elements one at a time in a single thread.
Parallel Stream: Processes elements concurrently using multiple threads.

stringjoiner
===========
StringJoiner is a utility class introduced in Java 8, part of the java.util package. It provides a flexible way to construct a string with a specified delimiter, optional prefix, and suffix. 
It's particularly useful for concatenating strings in a controlled manner, such as when joining elements of a collection with a specific format.

Key Features of StringJoiner
Delimiter: Specifies the character or string to insert between the elements being joined.
Prefix and Suffix: Optionally add characters or strings before the first element and after the last element.
Immutability: Once constructed, a StringJoiner object cannot be modified directly, but you can use it to build a string incrementally.
import java.util.StringJoiner;

public class StringJoinerExample {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(", ", "[", "]");

        // Add elements to the StringJoiner
        joiner.add("Alice");
        joiner.add("Bob");
        joiner.add("Charlie");

        // Convert to string
        String result = joiner.toString();

        System.out.println(result); // Output: [Alice, Bob, Charlie]
    }
}

lambda expression ,method reference
Lambda expression
=====================
It is also known as annonymous function or closures.
Help us to write our code in functional style.it provides clear and concise way to implement single abstract method by using expression.
It is very useful in collection library in which it helps to iterate, filter and extract data
 They are particularly useful for passing behavior as arguments to methods and creating instances of functional interfaces.

In case of lambda expression  we don’t need to define the method for providing  the implementation we just need to write implementation code.
simple lambada function
---------------------------
// Lambda expression to add two numbers
BinaryOperator<Integer> add = (x, y) -> x + y;

// Using the lambda expression

int result = add.apply(3, 5);
System.out.println(result);  // Output will be 8

Method referance
======================
in Java Method referance are a shorthand notation for calling methods that can be used wherever a functional interface is expected.
They provide a more concise and readable way to refer to methods compared to using lambda expressions.
They are particularly useful when the lambda expression simply calls an existing method or constructor, making your code more concise and expressive.

Type of method referance
Referance of static method
Referance of instance method
Referance of constructor by using new keyword

Mapping out the instance,static method or cinstructor by using :: colon operator.

// Lambda expression to convert a string to uppercase
        Function<String, String> toUpperCaseLambda = s -> s.toUpperCase();

        // Method reference to convert a string to uppercase
        Function<String, String> toUpperCaseMethodRef = String::toUpperCase;
//testing 
System.out.println(toUpperCaseLambda.apply("hello"));

Springboot
==================
springboot which version-below 3
Compatibility Overview
Spring Boot 1.x: The 1.x versions of Spring Boot support Java 8. For example, Spring Boot 1.2.x and later versions support Java 8.

Spring Boot 2.x: This major version also supports Java 8. Starting from Spring Boot 2.0.x, Java 8 is a supported version, but newer versions of Spring Boot in the 2.x line offer enhanced support and features.

Spring Boot 3.x: Starting with Spring Boot 3.0, Java 17 is required, but Spring Boot 2.x continues to support Java 8.

jdk compatibility
======================
which JDK version supported
scopes
==========

annotations
@Bean
what will compatibity
@configuration

cruicial diff dependancies
how will you make final

Rest API
pathvariable 
query 
Finding second highest salary from employees list
 
Reversing list of strings and sorting them in ascending order
2nd highest salary using SQL query

Asynchronous communication b/w micro services 
 
Dependency injection
 
Constructor vs setter injection which is better approach 
 
How do you handle production defwct
 Understand production  logs and  also  try to replicate same data in non prod environment to see similar issue was being faced or not
Exception handling in spring boot
 
Interface vs composition
 
Deployment in cloud server
 
	Asking to write url for get rest api
Restcontroller vs controller
RRequestmapping vs get mapping	

They were checking whether we are following standards while creating rest api uri

Scope of bean 
 
How do you check code quality and vulnerabilities in code...are you using any tool

Singleton Class, Create the Singleton Class in 2 ways.(direct and thread safe) 2. Hash Map implementation. 3. Thread related questions, Sync, Life Cycles, States. 4. ways of creating the thread, which do you prefer and why ? 5. Wait vs Sleep 6. Serialization. 7. Comparable vs Comparator 8. Rest API, Service, Annotation, Repository, JPA, Junit





