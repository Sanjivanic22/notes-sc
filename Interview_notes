OOP concepts
-=================
Object-Oriented Programming (OOP)** is a programming based on the concept of objects, which can contain data and methods. 
The four main principles of OOP are
**Encapsulation, Inheritance, Polymorphism,** and **Abstraction**. 

### 1. **Encapsulation**
Encapsulation refers to the bundling of data (fields) and methods (functions) that operate on the data into a single unit, typically a class. 
It restricts direct access to some of the object's components and can prevent accidental interference or misuse.

- **Purpose**: 
Protects object integrity by preventing external code from directly modifying fields. 
It helps in maintaining control over how data is accessed or modified.
- **How**: By using access modifiers like `private`, `public`, and `protected`.

#### Example:
```java
public class Car {
    private String model;
    private int year;

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }
}
```
Getters and setters method
==============================
In this example, the `model` and `year` fields are private, meaning they can only be accessed via the public getter and setter methods.
Getter and Setter methods control access to a class’s fields and provide flexibility, data validation, and encapsulation.
They ensure that fields are accessed in a controlled manner and can include additional logic such as validation, logging, or synchronization.
They allow for data hiding, read-only or write-only access, and maintain flexibility if internal data representation needs to change in the future.

what is differance b/w encapsulation and abstraction
============================================================
Encapsulation:
Encapsulation is used to secure the internal state of an object by restricting unauthorized access and modification.
It allows changes to the internal implementation without affecting external code that uses the class.
It provides data hiding by making fields private and exposing them through getter and setter methods.
Abstraction:
Abstraction is used to simplify complex systems by hiding unnecessary details and exposing only the essential information.
It allows developers to interact with objects without knowing their underlying implementation, making the system more user-friendly and less complex.

Key Differences:
Aspect	     Encapsulation	                                                              Abstraction
Definition	Bundles data and methods into a class and restricts direct access to fields.	Hides implementation details and shows only essential features.
           Purpose	Protects internal data and controls access.	                          Simplifies complexity by focusing on what an object does.
           Focus	Securing and controlling access to data.	                               Simplifying interaction by hiding details.
Implementation	Achieved using private fields and public getters/setters.              	Achieved using abstract classes, interfaces, and abstract methods.
Visibility	Controlled via access modifiers (private, public, etc.).	                  Hides internal logic; user only sees relevant features.

what is data hiding
=====================
Data hiding is a concept in (OOP) where internal details of a class (such as data members or fields) are hidden from external access. 
This ensures that the internal state of an object cannot be directly accessed or modified by external code. 
Instead, access is provided through controlled means such as getters and setters or other public methods.


### 2. **Inheritance**
Is_A relation(Inheritance)
============================
Inheritance represents the IS-A relationship which is also known as a parent-child relationship.
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. 
It provides code reusability. It is used to achieve runtime polymorphism
 .
 When you inherit from an existing class, you can reuse methods and fields of the parent class.

• By using extends keyword  we can implements is-a relationship

 there can be three types of inheritance in java:
=======================================================
single inheritance
-----------------
When a class inherits another class, it is known as a single inheritance.

multilevel 
--------------
When there is a chain of inheritance, it is known as multilevel inheritance.

hierarchical.
-------------------
When two or more classes inherits a single class, it is known as hierarchical inheritance.

multiple and hybrid inheritance is supported through interface only.

why multiple inheritance is supported by the java
----------------------------------------------------------
To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. 
If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

- **Purpose**: Promotes code reuse and establishes a natural hierarchy between classes.
- **How**: Use the `extends` keyword in Java to create a child class that inherits from a parent class.

#### Example:
```java
public class Vehicle {
    public void start() {
        System.out.println("Vehicle is starting");
    }
}

public class Car extends Vehicle {
    public void honk() {
        System.out.println("Car is honking");
    }
}
```

In this case, the `Car` class inherits the `start` method from the `Vehicle` class and adds its own method `honk`.

---

### 3. **Polymorphism**

Polymorphism in Java is a concept by which we can perform a single action in different ways
Polymorphism allows objects of different classes to be treated as objects of a common superclass.
 **Purpose**: Allows a single interface to be used for a general class of actions, making the system more flexible and scalable.

There are two types of polymorphism:

compile-time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.
Overloading
===============

 **Compile-time polymorphism (Method Overloading)**: When multiple methods have the same name but different parameter lists.
public class Calculator {
    // Overloaded method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method to add two double values
    public double add(double a, double b) {
        return a + b;
    }
}

Overriding
==============
If method names and arguments must be matched  i.e method signature must be matched is called overriding.
- **Run-time polymorphism (Method Overriding)**: When a subclass provides a specific implementation of a method that is already defined in its superclass.

class Animal {
    // Method to be overridden
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal reference, Animal object
        Animal myDog = new Dog();        // Animal reference, Dog object

        myAnimal.sound();  // Calls Animal's sound method
        myDog.sound();     // Calls Dog's sound method (overridden method)
    }
}

In this example, the `sound()` method is overridden in the `Dog` class. Although the object is of type `Animal`, the actual method invoked is from the `Dog` class, demonstrating runtime polymorphism.

### 4. **Abstraction**
Abstraction is the concept of hiding the implementation details and exposing only the essential features of an object.
It allows you to focus on what an object does rather than how it does it.

- **Purpose**: Simplifies complex systems by providing only the necessary details to the user.
- **How**: In Java, abstraction can be achieved using abstract classes or interfaces.

#### Example (Interface):
```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat implements Animal {
    public void sound() {
        System.out.println("Cat meows");
    }
}
```

In this example, both `Dog` and `Cat` implement the `Animal` interface and provide their own implementations of the `sound()` method. The user doesn't need to know how the `sound()` method works, just that it exists.

Diff b/w abstrcat class and interface
======================================

1. Purpose
Abstract Class: Used to represent a base class that other classes can inherit from. It can provide some default behavior while leaving 
some methods abstract for subclasses to implement.
Interface: Used to represent a contract that a class must adhere to. It’s purely about defining the behavior that implementing classes must provide,
without providing any implementation (until Java 8 introduced default methods).

2. Syntax
Abstract Class: Declared with the abstract keyword. It can have both abstract methods (without implementation) and concrete methods (with implementation).

abstract class Animal {
    abstract void sound(); // Abstract method
    void eat() { // Concrete method
        System.out.println("This animal eats");
    }
}
Interface: Declared with the interface keyword. It can have abstract methods , default methods (with implementation, introduced in Java 8), and static methods.
interface Animal {
    void sound(); // Abstract method
    default void eat() { // Default method (Java 8+)
        System.out.println("This animal eats");
    }
}

3. Method Implementation
Abstract Class: Can have both abstract and concrete methods. Subclasses can inherit and use the concrete methods or override them.
Interface: Prior to Java 8, all methods were implicitly abstract. From Java 8 onward, interfaces can have default and static methods with implementations.

5. Fields/Variables
Abstract Class: Can have instance variables (fields) and can define methods to manipulate these variables.

Interface: Can only have public, static, and final variables (essentially constants). Instance variables are not allowed.
abstract class Animal {
    int age; // Instance variable
}

interface Animal {
    int AGE = 10; // Constant (implicitly public, static, and final)
}
6. Constructors
Abstract Class: Can have constructors. These constructors are called when a subclass is instantiated.
Interface: Cannot have constructors because interfaces cannot be instantiated.
8. When to Use
Abstract Class:
Use when classes share a common base of code (fields or methods).
Use when you want to provide some common functionality that can be inherited by subclasses.
Use when you expect future classes to have many common methods or fields.

Interface:
Use to define a contract that multiple classes can implement.
Use when you want to achieve multiple inheritance in Java.
Use when you want to provide flexibility for unrelated classes to implement the same set of behaviors.

9. Example Use Cases
Abstract Class: A Vehicle abstract class where all vehicles have common properties (like speed, fuel) and behaviors (like startEngine()), but startEngine() may be implemented differently in subclasses (Car, Bike).

Interface: A Flyable interface for classes that can fly (Bird, Airplane), where each class implements its own version of the fly() method.

Marker interface
==================
If an interface wont contains any method & by implementing that interface if our object will get ability such type of interface are called marker interface.
An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, random access method.etc.

They are used to provide some essential information to the JVM so that JVM may perform some useful operation.

By implementing seriazable interface we can send object across the n/w and we can save state of object to a file this extra ability is provided through seriazable interface

By implemeting clonable interface our object will be in position to provide exactly duplicate object

As marker interface interface wont contain method them jvm is responsible for that to reduce complexity of program
We can create our own marker interfface but customization of jvm required.

Collection
Set 
Hashset
hashtable

List
is datastructor in collection whenere we want to represent group of individual object as single entity where duplicates are allowed and
insertion order is preserved then we can go for LIST .

diff b/w Arraylist and linkedlist

1. Underlying Data Structure:
ArrayList:
Internally, ArrayList is backed by a dynamic array (resizable array).
Elements are stored in a contiguous block of memory.

LinkedList:
Internally, LinkedList is implemented as a doubly linked list.
Each element (node) contains a reference to both the next and the previous node, making it a chain of elements connected via pointers.

2. Performance:
Access (Get/Set):
ArrayList:
Accessing elements is fast because it allows random access (constant-time access) via the index.
Time complexity for access is O(1).
Example: arrayList.get(index) is very efficient.

LinkedList:
Accessing elements is slower because it requires traversing the list from the beginning or end to reach the desired element.
Time complexity for access is O(n) for getting or setting an element by index.
Example: linkedList.get(index) will take longer if the index is near the end.

Insertion and Deletion:
ArrayList:
Inserting or deleting elements (especially in the middle or at the beginning) is slower because it requires shifting elements to make space or fill gaps.
Time complexity for insertion/deletion is O(n) in the worst case.
Insertion at the end of the ArrayList is generally O(1), unless the array needs to resize.

LinkedList:
Inserting or deleting elements is faster in a LinkedList, especially at the beginning or in the middle, because it only requires updating the links (pointers) between nodes.
Time complexity for insertion/deletion at the beginning or end is O(1).
Inserting in the middle of the list takes O(n) to traverse but O(1) to modify links.

Resizing:
ArrayList:
When the internal array fills up, ArrayList dynamically resizes itself (usually by doubling its size). This involves creating a new array and copying all elements, which takes time.

LinkedList:
LinkedList does not need resizing because it is not array-based. It just creates new nodes as needed, making it more efficient for frequently growing or shrinking lists.

3. Memory Usage:
ArrayList:
ArrayList requires less memory overhead because it only stores the data and an index pointer. However, when it resizes, it may allocate more memory than required (extra space for future elements).

LinkedList:
LinkedList uses more memory because, in addition to storing the data, it also stores two pointers (references) for each node (next and previous), which increases memory usage.

4. Use Cases:
ArrayList:
Best when you need fast access to elements using indexes.
Suitable for scenarios where elements are primarily added at the end, and random access is required.
Example: Storing frequently accessed data, like a list of cities where you need to access elements by index.

LinkedList:
Best when you need frequent insertions or deletions at the beginning or middle of the list.
Suitable for scenarios where the size of the list changes frequently and you don't need random access.
Example: Implementing a queue or stack, where elements are added/removed from the front or end frequently.

5. Implementation in Java:
ArrayList:
import java.util.ArrayList;

ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("Apple");
arrayList.add("Banana");
System.out.println(arrayList.get(1)); // Accessing element is fast

LinkedList:
java
Copy code
import java.util.LinkedList;

LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
linkedList.addFirst("Orange"); // Efficient insertion at the beginning
System.out.println(linkedList.get(1)); // Accessing element is slower



Map
=====
Hashmap implementation,how it function
Intenal working of hashmap and implementation
---------------------------------------------------
### Internal Working of a HashMap in Java

A **HashMap** in Java is a part of the `java.util` package and is one of the most commonly used data structures. It allows storing key-value pairs, where each key is unique.
The key is used to retrieve the value stored in the map. The main concept behind a HashMap is the use of a hash table, which allows for fast access to the data.

1. Hash Function
   - When a key-value pair is inserted into the HashMap, the key is passed through a hash function. The hash function generates an integer (hash code) that represents the key.
   - The hash code is then used to determine the index in the array (bucket) where the entry should be stored.

2. **Index Calculation**
   - The hash code is transformed into an index     
 3. **Collision Handling**
   - A collision occurs when two different keys produce the same index. 
HashMap handles collisions using a technique called **Separate Chaining
   - **Separate Chaining:** Each bucket in the array points to a linked list of entries that share the same index. 
When a collision occurs, the new entry is added to the linked list.

4. **Rehashing**
   - When the load factor (ratio of number of elements to the array size) exceeds a threshold (usually 0.75), the HashMap increases its array size (doubles it) and rehashes all entries.
   - Rehashing involves recalculating the index for each entry and moving it to the new array.
5. **Retrieving Values**
   - To retrieve a value, the key is passed through the same hash function to find the index.
   - The HashMap then traverses the linked list at that index to find the entry with the matching key.


Java Implementation of a Simple HashMap

public class HashMapImplementation<K, V> {
    private static final int INITIAL_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
 
    private Node<K, V>[] table;
    private int size = 0;
 
    public HashMapImplementation() {
        table = new Node[INITIAL_CAPACITY];
    }
 
    static class Node<K, V> {
        final K key;
        V value;
        Node<K, V> next;
 
        Node(K key, V value, Node<K, V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
 
    public void put(K key, V value) {
        int index = indexFor(key.hashCode(), table.length);
        Node<K, V> current = table[index];
        for (Node<K, V> node = current; node != null; node = node.next) {
            if (node.key.equals(key)) {
                node.value = value;
                return;
            }
        }
        table[index] = new Node<>(key, value, current);
        size++;
        if (size > table.length * LOAD_FACTOR) {
            resize(2 * table.length);
        }
    }
 
    public V get(K key) {
        int index = indexFor(key.hashCode(), table.length);
        Node<K, V> node = table[index];
        while (node != null) {
            if (node.key.equals(key)) {
                return node.value;
            }
            node = node.next;
        }
        return null;
    }
 
    private int indexFor(int hashCode, int length) {
        return hashCode & (length - 1);
    }
 
    private void resize(int newCapacity) {
        Node<K, V>[] oldTable = table;
        table = new Node[newCapacity];
        size = 0;
        for (Node<K, V> head : oldTable) {
            while (head != null) {
                put(head.key, head.value);
                head = head.next;
            }
        }
    }
}
Concurrenthashmap-its sychronous or asyncronous
ConcurrentHashMap is a class in Java from the java.util.concurrent package that provides a thread-safe and high-performance implementation of a hash table. It is designed to allow concurrent access to multiple threads without requiring the use of external synchronization mechanisms like manually locking the entire map. This makes it ideal for use in multithreaded environments where read and write operations are performed frequently by different threads.

Key Features of ConcurrentHashMap:
Thread-Safety:

ConcurrentHashMap allows concurrent read and write operations by dividing the map into segments (or buckets). Multiple threads can read and write to different segments concurrently without locking the entire map.
It avoids performance bottlenecks typically associated with fully synchronized collections like Hashtable or Collections.synchronizedMap().
No Null Keys or Values:

Unlike HashMap, ConcurrentHashMap does not allow null keys or values. If you try to insert a null key or value, it throws a NullPointerException.
Segmented Locking (Optimized Locking Mechanism):

Internally, ConcurrentHashMap uses a technique called segment locking (or bucket locking). Instead of locking the entire map, it only locks specific segments (or buckets) when modifying them, allowing higher concurrency.
Multiple threads can update the map simultaneously as long as they operate on different segments.
High Performance:

The map supports a high degree of concurrency, making it much faster than Hashtable or synchronizedMap when dealing with large data sets or frequent updates.
Read operations are generally non-blocking, which improves performance in read-heavy scenarios.
Atomic Operations:

ConcurrentHashMap provides methods for atomic operations like putIfAbsent(), remove(), replace(), which allow certain operations to be done in a thread-safe manner without needing explicit locks.
Weak Consistency:

Iterators returned by ConcurrentHashMap are weakly consistent. This means that they do not throw ConcurrentModificationException if the map is modified during iteration. Instead, they reflect the state of the map at the time they were created and may reflect some updates made after their creation.
However, they do not guarantee to show all updates made after the iterator was created.

When to Use ConcurrentHashMap:
When you need a thread-safe map and want to avoid performance bottlenecks caused by full synchronization in a multi-threaded environment.
When you need a map for read-heavy workloads, but occasional updates are necessary.
When you need fine-grained locking for frequent updates without affecting the performance of other operations.

Key Differences Between HashMap, Hashtable, and ConcurrentHashMap:
======================================================================
Feature	HashMap	             Hashtable	                                     ConcurrentHashMap
Thread-Safety	Not thread-safe	Thread-safe (synchronized)	Thread-safe with high concurrency
Null Keys/Values	Allows null keys/values	Does not allow null keys/values	Does not allow null keys/values
Performance	Fast, but not safe for concurrency	Slower due to full synchronization	Better performance in multithreaded scenarios
Locking Mechanism	No locking	Locks the entire map	Fine-grained locking on segments/buckets
Iterator Consistency	Fail-fast	Fail-fast	Weakly consistent

Concurrenthashmapmodificationexception
concurrentModificationEXaception
----------------------
A ConcurrentModificationException in Java is thrown when a collection (e.g., ArrayList, HashMap) is modified while being iterated over 
using methods like Iterator or enhanced for loop. This exception is typically encountered when you modify the collection directly 
(e.g., using add, remove, or put methods) during iteration.
7)concurrentModificatiobRxception
====================================
List <Integer> list=new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
try{
Iterator <Integer> iterator=new Iterator<>();
Integer value=iterator.next();
while(iterator.hashNext){
if(value%2==0){
list.remove(list);
} }
catch(concurrentModificatiobRxception e){
Systrm.out.println("concurrentModificatiobRxception caugght"+e);
Sysout("list after modification attempt "+ list);

}
}
Thread life cycle
===================
1. New state
Definition: When a thread is created, it is in the new state. It remains in this state until the start() method is called.

Example:
Thread thread = new Thread(new RunnableTask()); // Thread is in NEW state

2. Runnable
Definition: When the start() method is called on a thread, it moves to the runnable state. In this state, the thread is eligible to run by the JVM, but it is not running yet. 
The actual running of the thread depends on the thread scheduler.

Example:
thread.start(); // Thread moves to RUNNABLE state

3. Blocked
Definition: A thread enters the blocked state when it is waiting for a monitor lock to enter a synchronized block/method.

Example:
synchronized (lock) {
    // Critical section
}
If a thread tries to enter this synchronized block and the lock is already held by another thread, it will move to the blocked state.

4. Waiting
Definition: A thread enters the waiting state when it is waiting indefinitely for another thread to perform a particular action (e.g., waiting on an object's monitor with Object.wait()).

Example:
synchronized (lock) {
    lock.wait(); // Thread enters WAITING state
}
5. Timed Waiting
Definition: A thread enters the timed waiting state when it is waiting for another thread to perform a specific action within a stipulated time.
This can happen with methods like Thread.sleep(), Object.wait(long timeout), Thread.join(long millis), etc.

Example:
Thread.sleep(1000); // Thread enters TIMED_WAITING state
6. Terminated
Definition: A thread enters the terminated state once its run() method completes or when it is explicitly terminated (e.g., by an uncaught exception).

Example:
class RunnableTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

what are java 8 features
functinonal interface
A functional interface in Java is an interface that contains exactly one abstract method. These interfaces are meant to represent a single function or operation,
which can be implemented or passed around like a function pointer or lambda expression. 
Functional interfaces are a key component in enabling lambda expressions and method references in Java, starting with Java 8.
Single Abstract Method (SAM):

A functional interface has exactly one abstract method. This single method defines the interface's functionality.
The method can be implemented using a lambda expression or a method reference.

@FunctionalInterface Annotation:
While not mandatory, it's common to annotate functional interfaces with the @FunctionalInterface annotation. This helps the compiler ensure that the interface conforms to the functional interface specification (i.e., it contains only one abstract method).
If the interface has more than one abstract method, the compiler will throw an error.

Default and Static Methods:
Functional interfaces can have default and static methods in addition to the single abstract method.
These do not count as abstract methods and do not affect the functional nature of the interface.

streams(interme)
IntStream is a specialized stream in Java. It is designed to work specifically with primitive int values, avoiding the overhead of autoboxing that occurs when using the regular Stream<Integer> for integer streams.

The IntStream provides several useful methods for processing sequences of int values in a functional programming style, similar to how the regular 
Stream works with objects. It supports a variety of operations such as filtering, mapping, reducing, sorting, etc., all tailored to int primitives.

filter and map diff
Key Differences
Functionality:
filter: Selects elements based on a condition. It removes elements that do not meet the criterion.
map: Transforms elements based on a function. It modifies each element to produce a new form.

Input and Output:
filter: Takes a Predicate<T> and returns a stream of elements that match the predicate.
map: Takes a Function<T, R> and returns a stream of elements that are the result of applying the function to each original element.

Usage in a Pipeline:
You often use filter before map in a stream pipeline to first reduce the number of elements and then transform the remaining elements.

consumer ,supplier
========================
Key Differences
Purpose
Consumer: Takes an input and performs an action without returning a result. It is used for operations that consume data.
Supplier: Provides a result without requiring any input. It is used for producing or generating values.
Method:

Consumer: accept(T t)
Supplier: get()
Use Cases:
Consumer: Typically used in scenarios where an action needs to be performed on an input (e.g., printing or updating values).
Supplier: Typically used in scenarios where values need to be provided or generated (e.g., factory methods or default values).

Functional Composition:
Consumer: Can be composed using andThen to perform sequential actions.
Supplier: Does not have built-in composition but can be combined with other functional interfaces in a broader context.

stream -optional
Key Characteristics of Optional:
Purpose:
To represent a value that might be present or absent, thus reducing the risk of NullPointerException.
To provide a more expressive way of handling cases where a value might be missing.

Common Methods:

isPresent(): Checks if a value is present.
ifPresent(Consumer<? super T> action): Executes a given action if the value is present.
get(): Retrieves the value if present, otherwise throws NoSuchElementException.
orElse(T other): Returns the value if present, otherwise returns the provided default value.

parallel stream
==================

In Java, parallel streams provide a way to process collections of data in parallel, leveraging multi-core processors to potentially speed up computations. The Streams API, introduced in Java 8, includes support for parallel streams, allowing for concurrent processing of elements.
Parallel Streams allow for concurrent processing of data using multiple threads, potentially improving performance for large datasets or computationally intensive tasks.
parallelStream() creates a parallel stream from a collection, and parallel() can be used to convert a sequential stream to parallel.

Key Concepts of Parallel Streams
Parallel vs. Sequential Streams:
sequential Stream: Processes elements one at a time in a single thread.
Parallel Stream: Processes elements concurrently using multiple threads.

stringjoiner
===========
StringJoiner is a utility class introduced in Java 8, part of the java.util package. It provides a flexible way to construct a string with a specified delimiter, optional prefix, and suffix. 
It's particularly useful for concatenating strings in a controlled manner, such as when joining elements of a collection with a specific format.

Key Features of StringJoiner
Delimiter: Specifies the character or string to insert between the elements being joined.
Prefix and Suffix: Optionally add characters or strings before the first element and after the last element.
Immutability: Once constructed, a StringJoiner object cannot be modified directly, but you can use it to build a string incrementally.
import java.util.StringJoiner;

public class StringJoinerExample {
    public static void main(String[] args) {
        StringJoiner joiner = new StringJoiner(", ", "[", "]");

        // Add elements to the StringJoiner
        joiner.add("Alice");
        joiner.add("Bob");
        joiner.add("Charlie");

        // Convert to string
        String result = joiner.toString();

        System.out.println(result); // Output: [Alice, Bob, Charlie]
    }
}

lambda expression ,method reference
Lambda expression
=====================
It is also known as annonymous function or closures.
Help us to write our code in functional style.it provides clear and concise way to implement single abstract method by using expression.
It is very useful in collection library in which it helps to iterate, filter and extract data
 They are particularly useful for passing behavior as arguments to methods and creating instances of functional interfaces.

In case of lambda expression  we don’t need to define the method for providing  the implementation we just need to write implementation code.
simple lambada function
---------------------------
// Lambda expression to add two numbers
BinaryOperator<Integer> add = (x, y) -> x + y;

// Using the lambda expression

int result = add.apply(3, 5);
System.out.println(result);  // Output will be 8

Method referance
======================
in Java Method referance are a shorthand notation for calling methods that can be used wherever a functional interface is expected.
They provide a more concise and readable way to refer to methods compared to using lambda expressions.
They are particularly useful when the lambda expression simply calls an existing method or constructor, making your code more concise and expressive.

Type of method referance
Referance of static method
Referance of instance method
Referance of constructor by using new keyword

Mapping out the instance,static method or cinstructor by using :: colon operator.

// Lambda expression to convert a string to uppercase
        Function<String, String> toUpperCaseLambda = s -> s.toUpperCase();

        // Method reference to convert a string to uppercase
        Function<String, String> toUpperCaseMethodRef = String::toUpperCase;
//testing 
System.out.println(toUpperCaseLambda.apply("hello"));

Springboot
==================
springboot which version-below 3
Compatibility Overview
Spring Boot 1.x: The 1.x versions of Spring Boot support Java 8. For example, Spring Boot 1.2.x and later versions support Java 8.

Spring Boot 2.x: This major version also supports Java 8. Starting from Spring Boot 2.0.x, Java 8 is a supported version, but newer versions of Spring Boot in the 2.x line offer enhanced support and features.

Spring Boot 3.x: Starting with Spring Boot 3.0, Java 17 is required, but Spring Boot 2.x continues to support Java 8.

jdk compatibility
======================
which JDK version supported
scopes
==========

annotations
@Bean
what will compatibity
@configuration


how will you make final

Rest API
pathvariable 
query 
Finding second highest salary from employees list
 
Reversing list of strings and sorting them in ascending order
2nd highest salary using SQL query

Asynchronous communication b/w micro services 
 Asynchronous communication between microservices refers to a messaging pattern where services exchange data or requests without waiting for an immediate response. This allows microservices to function independently, improving system scalability, 
fault tolerance, and responsiveness. Instead of sending a request and blocking the process until a response is received (as is the case in **synchronous communication**), asynchronous communication sends the request and processes the response when it becomes available.

### **Why Asynchronous Communication?**
In microservices architecture, asynchronous communication is often preferred in situations where:
- **Loose coupling** is required, meaning services can operate and evolve independently.
- **Higher scalability** is needed because services don’t block and wait for responses.
- **Improved fault tolerance** is crucial, allowing services to handle failures and retries gracefully.
- **Event-driven systems** are in use, where services react to changes or triggers in the system.

### **Ways to Implement Asynchronous Communication Between Microservices:**

1. **Message Brokers (Pub/Sub Model)**:
   - Message brokers act as intermediaries, facilitating communication between microservices by receiving messages from one service and delivering them to others.
   - Examples of message brokers include **RabbitMQ**, **Apache Kafka**, **ActiveMQ**, and **Amazon SQS**.
   
   #### Workflow:
   - **Producer service** publishes messages to a **topic** or **queue** on the message broker.
   - The message broker stores the message temporarily until a **consumer service** reads and processes it.
   - Consumers subscribe to specific topics or queues, and once a message is published, the broker delivers it to the consumer.
   - This decouples the producer and consumer, enabling them to operate independently.

   #### Example with RabbitMQ:
   ```java
   // Producer sends a message
   @Autowired
   private RabbitTemplate rabbitTemplate;

   public void sendMessage(String message) {
       rabbitTemplate.convertAndSend("my-exchange", "my-routing-key", message);
   }

   // Consumer receives a message
   @RabbitListener(queues = "my-queue")
   public void receiveMessage(String message) {
       System.out.println("Received message: " + message);
   }
   ```

2. **Event-Driven Architecture (EDA)**:
   - In an event-driven system, microservices communicate through **events**. One service generates an event, which is consumed by other services that are interested in the event.
   - **Apache Kafka**, **AWS SNS/SQS**, or **Google Pub/Sub** are popular tools for managing events in microservices.
   
   #### Workflow:
   - A service (event producer) emits an **event** when a particular action occurs (e.g., order created, payment processed).
   - Other services (event consumers) **listen** for these events and perform actions based on the event data.
   - Events can be broadcasted to multiple services, enabling parallel processing of tasks.

   #### Example with Kafka:
   ```java
   // Producer: Publish an event to Kafka
   @Autowired
   private KafkaTemplate<String, String> kafkaTemplate;

   public void publishEvent(String message) {
       kafkaTemplate.send("my-topic", message);
   }

   // Consumer: Listen to Kafka topic for events
   @KafkaListener(topics = "my-topic", groupId = "my-group")
   public void listenToEvent(String message) {
       System.out.println("Received event: " + message);
   }
   ```

3. **Event Sourcing and CQRS**:
   - **Event Sourcing** involves storing the state of the system as a sequence of events rather than as snapshots of the data.
   - The **Command Query Responsibility Segregation (CQRS)** pattern separates the read and write operations of a system into different models.
   - This is often used in systems where maintaining the complete history of changes is important.
   
   #### Workflow:
   - **Event sourcing** stores every change in the system as an event in an event store (e.g., Kafka or a custom event store).
   - **CQRS** ensures that the commands (writes) and queries (reads) are handled by separate components, making the system more scalable and maintainable.

4. **Callback Mechanism**:
   - In some cases, a service may send a request to another service and expect a response later (asynchronously) via a callback mechanism.
   - The service receiving the request processes it and later calls back the original service with the result or status.
   
   #### Workflow:
   - Service A sends a request to Service B but does not block for a response.
   - Service B processes the request and sends a callback or notification to Service A when it completes the task.

5. **WebSockets and Server-Sent Events (SSE)**:
   - In cases where real-time bidirectional communication is required, WebSockets or **Server-Sent Events (SSE)** can be used.
   - WebSockets enable full-duplex communication, where both the client and server can send messages independently of each other.
   - SSE allows servers to push updates to clients over HTTP.
   
   #### Example with SSE:
   ```java
   @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
   public Flux<String> streamEvents() {
       return Flux.interval(Duration.ofSeconds(1))
                  .map(sequence -> "Event: " + sequence);
   }
   ```

### **Advantages of Asynchronous Communication**:
1. **Loose coupling**: Asynchronous communication allows microservices to be decoupled. Each service can operate independently and evolve without affecting others.
2. **Scalability**: Non-blocking communication allows services to handle large volumes of requests efficiently.
3. **Fault tolerance**: If one service fails, the messages are typically stored in a queue and retried once the service becomes available.
4. **Improved performance**: Services do not need to wait for a response, allowing the system to handle more requests concurrently.
5. **Resilience**: With message brokers, services can be resilient to temporary network failures or unavailability of other services.

### **Challenges of Asynchronous Communication**:
1. **Complexity**: Asynchronous systems are harder to design, as the flow of data and control is less straightforward.
2. **Debugging and monitoring**: Tracing the flow of events and messages across services can be more difficult compared to synchronous calls.
3. **Consistency**: Managing data consistency can be tricky in an eventual consistency model (common in asynchronous systems).
4. **Message loss**: If not handled properly, there is a risk of losing messages in case of failures in the message broker or network issues.
5. **Latency**: While asynchronous communication improves scalability, it can introduce delays in the processing of requests.

### **Best Practices for Asynchronous Communication**:
- **Idempotency**: Ensure that your services are idempotent so that repeated processing of the same message or event does not result in inconsistent data.
- **Retry and backoff**: Implement retry mechanisms with exponential backoff to handle transient failures.
- **Monitoring and tracing**: Use distributed tracing tools (e.g., **Jaeger**, **Zipkin**) to trace messages across services and monitor message flows for easier debugging.
- **Error handling**: Implement robust error handling and dead-letter queues (DLQs) to capture messages that cannot be processed.

### **Conclusion**:
Asynchronous communication is essential in microservice architectures for building scalable, resilient, and decoupled systems. By using message brokers, event-driven designs, or even callback mechanisms, services can operate independently while still exchanging necessary data. However, it requires careful design to handle challenges like eventual consistency, message loss, and debugging.

Constructor vs setter injection which is better approach 
===========================================================
 **Constructor Injection** and **Setter Injection** are two common ways to inject dependencies in **Spring** or other dependency injection (DI) frameworks. Both approaches have their advantages and disadvantages, and the choice depends on various factors such as code clarity, immutability, and design needs.
### **1. Constructor Injection**

In **Constructor Injection**, dependencies are provided through the class's constructor. This is often considered the more preferred way because it ensures that the object is created in a fully initialized state.
#### Example:

public class Car {
    private Engine engine;

    // Constructor Injection
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving...");
    }
}
#### Advantages:
1. **Immutability**: Once the object is created, the dependencies are fixed, making the object immutable. This makes the code more reliable and less error-prone.
2. **Mandatory dependencies**: Since the dependency is passed through the constructor, it is guaranteed that the object is fully initialized when created. This makes it impossible to create the object without the necessary dependencies.
3. **Thread-safety**: Objects created using constructor injection are more likely to be thread-safe because their dependencies are assigned once and cannot be changed.
4. **Testability**: Constructor injection makes unit testing easier because you can pass mock dependencies directly when creating the object.
5. **Best for required dependencies**: For dependencies that are essential to the object’s operation, constructor injection ensures that those dependencies are present and cannot be missed.

#### Disadvantages:
1. **Too many dependencies**: If a class has many dependencies, the constructor can become unwieldy with many parameters, making the code harder to read and maintain.
2. **No flexibility**: Dependencies cannot be changed after the object is created, which can be a disadvantage if the application requires changing dependencies at runtime (though this is rare).

### **2. Setter Injection**

In **Setter Injection**, dependencies are provided through public setter methods after the object has been created. This method allows you to inject dependencies later in the lifecycle of the object.
#### Example:
public class Car {
    private Engine engine;

    // Setter Injection
    public void setEngine(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is driving...");
    }
}
```

#### Advantages:
1. **Optional dependencies**: If a dependency is optional, setter injection provides flexibility to set it later. The object can still be created even if the dependency is not provided immediately.
2. **Flexibility**: Dependencies can be changed after the object is created, allowing for more dynamic configurations (e.g., in some cases where dependencies might change during the application's runtime).
3. **Simpler constructors**: Since dependencies are injected via setters, the constructor remains simple, without requiring multiple parameters.

#### Disadvantages:
1. **Lack of immutability**: Setter injection can make objects mutable, as dependencies can be modified after the object is created. This can introduce errors, especially in multi-threaded environments.
2. **Object may be in an inconsistent state**: With setter injection, an object can be created without necessary dependencies, which can lead to runtime errors if the setters are not called before the object is used.
3. **Harder to enforce dependencies**: It's easier to forget to inject a required dependency, and there is no compile-time guarantee that all necessary dependencies have been provided.
4. **Not ideal for mandatory dependencies**: If a dependency is essential for the class, relying on setter injection can lead to issues if the setter is never called or is called incorrectly.

### **Comparison: Constructor Injection vs. Setter Injection**

| Feature                            | Constructor Injection                      | Setter Injection                         |
|------------------------------------|--------------------------------------------|------------------------------------------|
| **Immutability**                   | Provides immutability once constructed     | Allows mutable objects, changing dependencies later |
| **Mandatory vs. Optional Dependencies** | Best for mandatory dependencies            | Best for optional dependencies           |
| **Consistency**                    | Ensures the object is fully initialized    | Risk of using the object in an inconsistent state |
| **Flexibility**                    | Less flexible (dependencies are fixed)     | More flexible (dependencies can change)  |
| **Testability**                    | Easily testable with constructor-based injection | Testable, but requires more setup        |
| **Thread-safety**                  | More thread-safe, since dependencies are final | Less thread-safe, dependencies can change at runtime |
| **Complexity in Constructor**      | Can result in long constructors if there are many dependencies | Keeps constructors simple                |
| **Dependency Enforcement**         | Compile-time guarantee for required dependencies | No compile-time enforcement, setters must be manually invoked |
| **Best Use Case**                  | Use for required, non-optional dependencies | Use for optional or runtime-configurable dependencies |

### **Which Is Better?**

#### **Constructor Injection is generally better when:**
- Dependencies are mandatory and should not change after object creation.
- You want to ensure that the object is fully initialized in a valid state.
- You are following the principle of **immutability**.
- You need better testability and thread safety.

#### **Setter Injection is better when:**
- You have optional dependencies.
- You need to inject dependencies later in the object’s lifecycle or change them dynamically.
- You want a more flexible, configurable object where dependencies can be altered after creation.

### **Conclusion:**
- **Use constructor injection for required dependencies** to enforce consistency and immutability.
- **Use setter injection for optional dependencies** or when you need more flexibility in modifying dependencies after object creation.

In general, **constructor injection** is considered the best practice, particularly in frameworks like **Spring**, because it ensures that an object is fully initialized in a valid state. However, **setter injection** has its place when flexibility is needed.
How do you handle production defect
===========================================
 Understand production  logs and  also  try to replicate same data in non prod environment to see similar issue was being faced or not

Exception handling in spring boot
 
Interface vs composition
=============================
 2. Composition
Composition refers to a design principle in which one object contains another object and delegates responsibilities to the contained object. Instead of inheriting from a parent class, an object gets the functionality by using instances of other classes. This is often expressed as a "has-a" relationship.

Key Features:
Reuse of code: Allows a class to achieve functionality by using (or containing) instances of other classes.
Delegation: The composed objects can delegate certain responsibilities to other objects, leading to more flexible and maintainable code.
Dynamic behavior: Objects can be composed of different components at runtime, making the behavior more flexible compared to inheritance.
Favors composition over inheritance: The idea behind composition is to avoid the limitations of inheritance (tight coupling, inflexibility, etc.).

Deployment in cloud server
=================================
Summary of Steps for Cloud Deployment:
Choose your cloud provider (AWS, Azure, GCP).
Set up the infrastructure (VMs, App Services, Functions, etc.).
Package and upload your application.
Deploy using appropriate tools (CLI, SDK, or Portal).
Configure networking, security, and scaling options.
Automate deployment using CI/CD pipelines.
Monitor and scale your application as necessary.

Asking to write url for get rest api
======================================
GET	/api/v1/users
Restcontroller vs controller

Requestmapping vs get mapping	

They were checking whether we are following standards while creating rest api uri
structure the URIs:
==========================

HTTP Method	URI	Action
GET	/api/v1/users	Retrieve all users
GET	/api/v1/users/{userId}	Retrieve a specific user
POST	/api/v1/users	Create a new user
PUT	/api/v1/users/{userId}	Update an existing user
DELETE	/api/v1/users/{userId}	Delete a user
GET	/api/v1/users/{userId}/posts	Retrieve all posts for a specific user
POST	/api/v1/users/{userId}/posts	Create a new post for a specific user
GET	/api/v1/posts	Retrieve all posts
GET	/api/v1/posts/{postId}	Retrieve a specific post
PUT	/api/v1/posts/{postId}	Update a specific post
DELETE	/api/v1/posts/{postId}	Delete a specific post

Scope of bean
====================
 In Spring Framework, the scope of a bean defines the lifecycle and visibility of the bean within the Spring container.
Understanding bean scopes is crucial for managing how beans are created, shared, and destroyed. 

### 1. **Singleton**

- **Description**: The default scope in Spring. Only one instance of the bean is created per Spring IoC container. This instance is shared across the entire application.
- **Lifecycle**: Created once and cached. The same instance is returned every time the bean is requested.
- **Usage**: Use when you need a single, shared instance of a bean, such as for service classes or data access objects.

```java
@Component
@Scope("singleton")
public class SingletonBean {
    // Bean code here
}
```
### 2. **Prototype**

- **Description**: A new instance of the bean is created each time it is requested from the Spring container.
- **Lifecycle**: The bean is created and initialized every time it is requested. The container does not manage its complete lifecycle.
- **Usage**: Use when you need multiple instances of a bean with different states, such as for user sessions or unique data objects.

@Component
@Scope("prototype")
public class PrototypeBean {
    // Bean code here
}

### 3. **Request**

- **Description**: A new instance of the bean is created for each HTTP request. The bean is scoped to a single HTTP request and is destroyed when the request is completed.
- **Lifecycle**: The bean instance is created for each HTTP request and is destroyed at the end of the request.
- **Usage**: Use in web applications when you need a bean that should be unique to a single HTTP request, such as a form backing object or request-specific data.

```java
@Component
@Scope("request")
public class RequestScopedBean {
    // Bean code here
}
### 4. **Session**

- **Description**: A new instance of the bean is created for each HTTP session. The bean is scoped to a single HTTP session and is destroyed when the session expires.
- **Lifecycle**: The bean instance is created for each HTTP session and is destroyed when the session ends.
- **Usage**: Use when you need a bean to be tied to a user session, such as session attributes or user-specific settings.

@Component
@Scope("session")
public class SessionScopedBean {
    // Bean code here
}

### 5. **Application**

- **Description**: A new instance of the bean is created for the entire lifecycle of a ServletContext. This scope is typically used in a web application and is equivalent to the singleton scope in a web environment.
- **Lifecycle**: The bean is created once for the entire application context and shared across all requests and sessions.
- **Usage**: Use when you need a bean to be shared across the entire application context, such as for application-wide settings.

```java
@Component
@Scope("application")
public class ApplicationScopedBean {
    // Bean code here
}
```

### 6. **Websocket**

- **Description**: A new instance of the bean is created for each WebSocket session. This scope is used specifically in WebSocket applications.
- **Lifecycle**: The bean instance is created for each WebSocket session and is destroyed when the session ends.
- **Usage**: Use when you need a bean to be tied to a WebSocket session, such as for maintaining WebSocket-specific state.

```java
@Component
@Scope("websocket")
public class WebSocketScopedBean {
    // Bean code here
}
```

You can specify the scope using the `@Scope` annotation or configure it in the Spring XML configuration.

### Example in XML Configuration

```xml
<bean id="myBean" class="com.example.MyBean" scope="singleton"/>
<bean id="myPrototypeBean" class="com.example.MyPrototypeBean" scope="prototype"/>
<bean id="myRequestBean" class="com.example.MyRequestBean" scope="request"/>
<bean id="mySessionBean" class="com.example.MySessionBean" scope="session"/>
<bean id="myApplicationBean" class="com.example.MyApplicationBean" scope="application"/>
```

Choosing the appropriate bean scope helps manage bean lifecycle and resource usage effectively in your Spring applications.
How do you check code quality and vulnerabilities in code...are you using any tool
=============================================================================
there are many tools but we have used in our project is sonarQUbe
SonarQube: Provides comprehensive code quality analysis, including code smells, bugs, vulnerabilities, and code coverage. 
Supports multiple languages and integrates with various CI/CD pipelines.

Singleton Class, Create the Singleton Class in 2 ways.(direct and thread safe) 2. Hash Map implementation. 3. Thread related questions, Sync, Life Cycles, States. 4. ways of creating the thread, which do you prefer and why ? 5. Wait vs Sleep 6. Serialization. 7. Comparable vs Comparator 8. Rest API, Service, Annotation, Repository, JPA, Junit
check in CGP notes

concurrency 
=================
Concurrency in Java refers to the ability of the system to execute multiple threads simultaneously, enabling multitasking and parallelism in applications. 

Volatile Keyword:

The volatile keyword ensures that changes to a variable are visible to all threads. It prevents the JVM from caching the variable in registers, ensuring that every thread reads the latest value.

Race Condition:

A race condition occurs when multiple threads access a shared resource simultaneously, leading to unpredictable results.
Synchronization, atomic variables, and other thread safety mechanisms help prevent race conditions.

Atomic Variables:

Java provides atomic classes (AtomicInteger, AtomicBoolean, etc.) in the java.util.concurrent.atomic package, which support lock-free thread-safe operations on single variables.
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();


Parallelism vs. Concurrency:

Concurrency: Refers to executing multiple tasks (or threads) in overlapping time periods.

Parallelism: Refers to executing multiple tasks simultaneously, typically in a multi-core processor.

Concurrency in Java allows programs to perform multiple tasks simultaneously, improving efficiency and responsiveness. However, it introduces complexity due to the potential for issues like race conditions, deadlocks, and inconsistent state. Proper use of synchronization, thread safety mechanisms, and Java's concurrency utilities can help manage this complexity and build robust concurrent applications.


copy on arraylist

CopyOnWriteArrayList is a thread-safe variant of ArrayList provided in Java's java.util.concurrent package. Unlike ArrayList, which is not thread-safe, CopyOnWriteArrayList allows safe iteration and modification by multiple threads without the need for explicit synchronization.

How CopyOnWriteArrayList Works:
Copy-on-Write Mechanism:

When a thread modifies the list (e.g., by adding or removing elements), CopyOnWriteArrayList creates a new copy of the underlying array, applies the modification, and then replaces the old array with the new one.
This approach ensures that any iteration or read operation occurring concurrently with a write operation will see a consistent snapshot of the array before the modification. The read operations use the array that was in place at the time the iteration started.

Thread Safety:

Since each modification results in a new array being created, CopyOnWriteArrayList is inherently thread-safe for read and write operations. Multiple threads can safely read from the list while another thread modifies it.

Efficiency Considerations:

Read-heavy scenarios: CopyOnWriteArrayList is highly efficient for scenarios where the list is read frequently and modified infrequently because the reads are lock-free and don't incur synchronization overhead.

Write-heavy scenarios: It is less efficient in write-heavy scenarios because every write operation involves copying the entire array, which can be costly in terms of memory and performance.

Use Cases:
Event Listener Lists: A common use case is maintaining a list of event listeners, where the list is frequently iterated over (to notify listeners) but rarely modified.
Caching: Where data is read often and updated rarely.

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

public class CopyOnWriteArrayListExample {
    public static void main(String[] args) {
        List<String> list = new CopyOnWriteArrayList<>();

        // Adding elements
        list.add("Element1");
        list.add("Element2");
        list.add("Element3");

        // Iterating over the list
        for (String element : list) {
            System.out.println(element);
            // Modifying the list during iteration
            list.add("Element4"); // This won't cause ConcurrentModificationException
        }

        System.out.println("After iteration: " + list);
    }
}

Pros and Cons:
Pros:

Thread Safety: No need for explicit synchronization, making it easier to use in multi-threaded environments.
Consistency: Iterators over the list always see a consistent view of the list at the time the iteration started.
Cons:

Memory Overhead: Every modification results in a new array being created, which can be memory-intensive, especially for large lists.
Performance: Copying the array for every write operation can be costly in terms of time and resources, making it unsuitable for scenarios with frequent modifications.

Database

spring 
bean scope
dependency injection
@validated
The @Validated annotation in Spring Framework is used to trigger the validation of method parameters or bean properties, typically in the context of a Spring-managed bean. 
It works in conjunction with the @Valid annotation, which is used to validate individual method arguments, and can be used in controller classes or service layers to ensure that input data meets certain validation criteria.
@valid

Difference Between @Validated and @Valid:
@Valid:

Triggers validation on a single object or method parameter.
Typically used on method parameters, particularly in Spring MVC controllers or service methods.

@Validated:

Can be applied at the class level or method level.
Supports validation groups, allowing for more granular control over which constraints are applied.

Conclusion:
The @Validated annotation in Spring is a powerful tool for ensuring that your application's inputs are validated according to specific rules, improving data integrity and reducing errors. It works well in conjunction with other validation annotations and is particularly useful when different validation rules are required for different contexts.

Usage of @Validated in Spring:
At the Class Level:

When applied at the class level, @Validated enables the validation of method parameters within that class. It allows for group validation, meaning you can specify which validation group should be applied.
@Validated
public class MyService {

    public void createUser(@Valid @NotNull @Size(min = 5) String username) {
        // Service logic here
    }
}

In Spring Controllers:

In a Spring MVC controller, @Validated is often used in conjunction with @RequestBody, @ModelAttribute, or other method parameters to validate incoming data.

@RestController
@RequestMapping("/users")
@Validated
public class UserController {

    @PostMapping
    public ResponseEntity<String> createUser(@Valid @RequestBody UserDTO user) {
        // Controller logic here
        return ResponseEntity.ok("User created successfully");
    }
}
In this example, UserDTO would be validated according to the constraints defined in its class.

Validation Groups:

@Validated can be used to specify validation groups, allowing for conditional validation based on the context.


