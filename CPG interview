Singleton Class, Create the Singleton Class in 2 ways.(direct and thread safe) 
Direct singletone class
--------------------------

public class Printer {
//private static member
	private static Printer INSTANCE;
	//private constructor
	private Printer() {
		System.out.println("Printer::0-param constructor");
	}
	//factory method
	public static Printer getInstance() {
		if(INSTANCE==null)
			INSTANCE=new Printer();
	return INSTANCE;
	}
	//b.method
	public void printdata(String msg) {
		System.out.println(msg);
	}
}
public class Test {
	public static void main(String[] args) {
		Printer p1=null,p2=null;
		p1=Printer.getInstance();
		p2=Printer.getInstance();
		System.out.println(p1.hashCode());
		System.out.println(p2.hashCode());
		System.out.println("(p1==p2?)"+(p1==p2));
		p1.printdata("hello1");
		p2.printdata("hello2");
	}
}

Thread safe singletone class //DoubleCheckedlockingThreadSafe
public class SingleTone{
//volatile variable to ensure visibility of changes accros threads
	private static volatile  SingleTone instance;
	//private constructor to prevent instantaition
	private SingleTone() {
		//prevent instantaion via reflection
		if(instance!=null) {
			throw new RuntimeException("use getInstance method to get the single instance");
		}
	}
		//global access point for the single instance
		public static SingleTone getInstance() {
		if(instance==null) {
			synchronized (SingleTone.class) {//first check
				if(instance==null) {//double check
					instance=new SingleTone();
				}
			}
		}	
		return instance;
		}
		public void showMessage() {
			System.out.println("Hello from Singletone instance");
		}
}
public class Main {
public static void main(String[] args) {
	Runnable task=()->{
		//ThreadSafeSingleTone  singletone=ThreadSafeSingleTone.getInstance();
SingleTone singletone=SingleTone.getInstance();
		System.out.println(Thread.currentThread().getName()+"-"+singletone);
	singletone.showMessage();
	};
	//start multiple threads
	Thread thread1=new Thread(task,"Thread 1");
	Thread thread2=new Thread(task,"Thread 2");
	
	thread1.start();
	thread2.start();
	//wait for all thread to finish
	try {
		thread1.join();
		thread2.join();
		
	}catch (InterruptedException e) {
		e.printStackTrace();
	}
}
}
2. Hash Map implementation.
### Class Overview

public class HashMapImplementation<K, V> {
    private static final int INITIAL_CAPACITY = 16;
    private static final float LOAD_FACTOR = 0.75f;
 
    private Node<K, V>[] table;
    private int size = 0;
}
- **`K` and `V`**: These are generic types representing the key (`K`) and value (`V`) in the map.
- **`INITIAL_CAPACITY`**: This is the initial size of the hash table (array) that stores the entries (key-value pairs). It is set to 16.
- **`LOAD_FACTOR`**: This determines when the hash table should be resized to avoid collisions. A load factor of 0.75 means that the table will be resized when it is 75% full.
- **`table`**: This is an array of `Node<K, V>` that stores the entries. It represents the hash table.
- **`size`**: This keeps track of the number of key-value pairs stored in the map.

### Node Class

static class Node<K, V> {
    final K key;
    V value;
    Node<K, V> next;

    Node(K key, V value, Node<K, V> next) {
        this.key = key;
        this.value = value;
        this.next = next;
    }
}

- **`Node<K, V>`**: This is a static inner class that represents each entry in the hash map. Each node contains:
  - **`key`**: The key for the entry.
  - **`value`**: The value associated with the key.
  - **`next`**: A reference to the next node in the chain, which is used to handle collisions (through chaining).

### Constructor
public HashMapImplementation() {
    table = new Node[INITIAL_CAPACITY];
}
- **Constructor**: Initializes the `table` with an array of `Node` objects, with the initial capacity defined by `INITIAL_CAPACITY` (16 in this case).

### `put` Method
public void put(K key, V value) {
    int index = indexFor(key.hashCode(), table.length);
    Node<K, V> current = table[index];
    for (Node<K, V> node = current; node != null; node = node.next) {
        if (node.key.equals(key)) {
            node.value = value;
            return;
        }
    }
    table[index] = new Node<>(key, value, current);
    size++;
    if (size > table.length * LOAD_FACTOR) {
        resize(2 * table.length);
    }
}
```

- **`put(K key, V value)`**: This method adds a key-value pair to the map.
  - **`indexFor(key.hashCode(), table.length)`**: Computes the index in the array where the key-value pair should be stored. The `indexFor` method uses the hash code of the key and the length of the table to compute the index.
  - **Collision Handling (Chaining)**: If there's already a `Node` at the computed index, the code iterates through the linked list (`for` loop) to check if the key already exists. If it does, the value is updated. If not, a new `Node` is added at the beginning of the list.
  - **Resize Check**: After adding the new node, the method checks if the size of the map exceeds the `LOAD_FACTOR`. If it does, the table is resized (doubled in capacity) using the `resize` method.

### `get` Method

```java
public V get(K key) {
    int index = indexFor(key.hashCode(), table.length);
    Node<K, V> node = table[index];
    while (node != null) {
        if (node.key.equals(key)) {
            return node.value;
        }
        node = node.next;
    }
    return null;
}
```

- **`get(K key)`**: This method retrieves the value associated with the specified key.
  - **Index Calculation**: The method calculates the index where the key should be located.
  - **Search in Linked List**: It then traverses the linked list at that index, checking each node's key. If a match is found, it returns the corresponding value. If no match is found, it returns `null`.

### `indexFor` Method

```java
private int indexFor(int hashCode, int length) {
    return hashCode & (length - 1);
}
```

- **`indexFor(int hashCode, int length)`**: This method calculates the index in the array for a given hash code. The expression `hashCode & (length - 1)` ensures the index is within the bounds of the array.
  - **`& (length - 1)`**: This operation works efficiently when `length` is a power of 2, which is why the initial capacity is 16 (a power of 2). This bitwise operation effectively performs a modulo operation but is faster.

### `resize` Method

```java
private void resize(int newCapacity) {
    Node<K, V>[] oldTable = table;
    table = new Node[newCapacity];
    size = 0;
    for (Node<K, V> head : oldTable) {
        while (head != null) {
            put(head.key, head.value);
            head = head.next;
        }
    }
}
```

- **`resize(int newCapacity)`**: This method doubles the size of the table and rehashes all existing entries into the new table.
  - **Rehashing**: The method iterates through each `Node` in the old table, re-inserting them into the new, larger table. This process is necessary because the indices may change due to the increased table size.
  - **Resets Size**: The `size` is reset to `0` and incremented during re-insertion to accurately reflect the number of elements in the map after resizing.
public class Test {
public static void main(String[] args) {
	HashMap<String ,Integer> map=new HashMap();
	map.put("one",1);
	map.put("Two",2);
	map.put("three",3);
	
	System.out.println("Value for key is:"+map.get("One"));
	System.out.println("Value for key is:"+map.get("Two"));
	System.out.println("Value for key is"+map.get("Three"));
}
}

 3. Thread related questions, 
Synchronized
===============
public class SynchronizedDemo {
public static void main(String[] args)throws InterruptedException {
	Counter counter=new Counter();
	
	//create multiple thread that will increment counter
	Thread thread1=new Thread(()->incrementCounter(counter));
	Thread thread2=new Thread(()->incrementCounter(counter));
	Thread thread3=new Thread(()->incrementCounter(counter));
	
	//start thread
	thread1.start();
	thread2.start();
	thread3.start();
	
	//wait for all thread to finish
	try {
		thread1.join();
		thread2.join();
		thread3.join();
		
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	System.out.println("final count:"+counter.getCount());
}

private static Object incrementCounter(Counter counter) {
	//use Instream to replace loop
	
	IntStream.range(0, 1000).forEach(i->counter.increament());
	// TODO Auto-generated method stub
	return null;
}


}
Life Cycles, States.
class MyThread extends Thread {
	@Override
	public void run() {
	try {
		//simulate somework with sleep(timing waiting state)
		System.out.println(Thread.currentThread().getName()+"is in time waiting state");
		Thread.sleep(2000);
		//simulate a synchromized block (blocked state if another waiting thread is holing the lock)
		synchronized (this) {
			System.out.println(Thread.currentThread().getName()+"is in Runnble state");
		//wait idefinitely(waiting state)
			synchronized (this) {
			System.out.println(Thread.currentThread().getName()+"is in waiting state");
			wait();
			}
		}
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	}
}
public class ThreadLifeCycleDemo {
	 public static void main(String[] args) throws InterruptedException {
	        MyThread thread = new MyThread();
	        //new state
	        System.out.println(thread.getName()+"is in new state");
	        //start the thread(Runnable state)
	        thread.start();
	        System.out.println(thread.getName()+"is in Runnable state");
	        //insure thread moves to timed  waiting state
	        Thread.sleep(500);
//synchromize on the thread to simulate blocked state
	        synchronized (thread) {
				//notify the thread to move it out of waiting state
			thread.notify();
	        
	        	 }
	       //wait for the thread to finish(terminated state) 
	    thread.join();
	    System.out.println(thread.getName()+"is in terminated state");
	 }
	}
 4. ways of creating the thread, which do you prefer and why ? 
===================================================================
In Java, there are several ways to create and manage threads. Here are the most common methods:

1. Extending the Thread Class
You can create a new thread by extending the Thread class and overriding its run() method.

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}
2. Implementing the Runnable Interface
Another way to create a thread is by implementing the Runnable interface. You then pass an instance of the class to a Thread object and start the thread.

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start();
    }
}
5. Wait vs Sleep
public class SleepExample {

	public static void main(String[] args) {
		Thread thread=new Thread(()->{
			System.out.println("Thread going to sleep");
			try {
				Thread.sleep(3000);
			}
			catch(InterruptedException e) {
				e.printStackTrace();
				
			}
			System.out.println("Thread wake up after sleeping");
		});
		thread.start();
	}

}

public class WaitNotify {

	public static final Object lock=new Object();
	public static void main(String[] args) throws InterruptedException {
		Thread thread1=new Thread(()->{
			
			synchronized (lock) {
				try {
					System.out.println("THread 1:waiting for notification");
					lock.wait();
					System.out.println("thread 2 got notification");
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}); 
		
		Thread thread2=new Thread(()->{
		synchronized(lock) {
			System.out.println("Thread 1: waiting for notification");
			lock.notify();
			System.out.println("Thread 2 :notification sent");
		}	
		});
	thread1.start();
	Thread.sleep(1000);
	thread2.start();
}
}

 6. Serialization. 
=========================

public class Person {
private static final long serialVersionUID=1L;
private String name;
private int age;
private transient String  password;
public Person(String name, int age,String password) {
	super();
	this.name = name;
	this.age = age;
	this.password=password;
}
@Override
public String toString() {
	return "Person [name=" + name + ", age=" + age + "]";
}


}

public class SerializationDemo {

	public static void main(String[] args) {
		Person person=new Person("John Doe",30,"mySecretPassword");
		try(FileOutputStream fileOut=new FileOutputStream("C:\\Users\\SCHATTEK\\Desktop\\New folder\\Sanj.txt"); 
			ObjectOutputStream out=new ObjectOutputStream(fileOut)){
			out.writeObject(person);
			System.out.println("Serialize data is saved in Desktop");
		
		} catch (IOException i) {
			i.printStackTrace();
		}
	}

}

public class DeserializeDemo {

	public static void main(String[] args) {
		Person person=null;
		try(FileInputStream fileIn=new FileInputStream("C:\\Users\\SCHATTEK\\Desktop\\New folder\\Sanj.txt");
		ObjectInputStream in=new ObjectInputStream(fileIn))
		{
					person =(Person)in.readObject();
					System.out.println("Deseriliazed person"+person);
		}catch (IOException |ClassNotFoundException e) {
				e.printStackTrace();
			}
				}
	}



7. Comparable vs Comparator 
comparable
package com.nt.compare;

public class Person implements Comparable<Person>{
String name;
private int age;

	public Person(String name, int age) {
	super();
	this.name = name;
	this.age = age;
}

	@Override
	public int compareTo(Person o) {
	return Integer.compare(this.age, o.age);
		
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	@Override
	public String toString() {
		return name+" "+age;
	}
	

}

public class Main {
public static void main(String[] args) {
	List<Person> people=new ArrayList<>();
	people.add(new Person("Sanju",27));
	people.add(new Person("Kunal",23));
	people.add(new Person("Nikhil",27));
	
	//Collections.sort(people);//ordering by age
	Collections.sort(people,new NameComparator());
	System.out.println(people);
}
}

Compaartor
===============
public class NameComparator implements Comparator<Person>{

	@Override
	public int compare(Person o1, Person o2) {
		return o1.name.compareTo(o2.getName());
	
	}

}

8. Rest API
@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}

, Service, Annotation, Repository, JPA, Junit
package com.example.hitcounter;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.concurrent.atomic.AtomicInteger;

@RestController
public class HitCounterController {

    // AtomicInteger is used to handle concurrency and ensure thread-safety.
    private final AtomicInteger counter = new AtomicInteger(0);

    // Define a GET endpoint at "/hit"
    @GetMapping("/hit")
    public String hit() {
        // Increment the counter and return the current count
        int currentCount = counter.incrementAndGet();
        return "API hit count: " + currentCount;
    }
}

without using AtomicIntegere
----------------------------------
package com.example.hitcounter;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HitCounterController {

    // Simple integer counter
    private int counter = 0;

    // Synchronized method to handle thread safety
    @GetMapping("/hit")
    public synchronized String hit() {
        counter++;
        return "API hit count: " + counter;
    }
}

SQL
-------
Index
An index in SQL is a database object that improves the speed of data retrieval operations on a table by providing quick access to rows.
Indexes are especially useful for columns that are frequently searched, filtered, or sorted. However, indexes come with some trade-offs,
such as increased storage space and slower write operations (inserts, updates, deletes) due to the need to update the index.

1. Types of Indexes
	• Single-Column Index: An index on a single column of a table.
	• Composite Index (Multi-Column Index): An index on two or more columns of a table.
	• Unique Index: Ensures that the values in the indexed column(s) are unique.
	• Full-Text Index: Used for full-text searches in columns containing large text data.
	• Clustered Index: Determines the physical order of data in the table (usually the primary key).
	• Non-Clustered Index: A separate structure that points to the data in the table.

2. Creating an Index
Single-Column Index
---------------------
CREATE INDEX idx_column_name
ON table_name(column_name);
Example: If you have a customers table and frequently search by the last_name column:

CREATE INDEX idx_last_name
ON customers(last_name);

Composite Index (Multi-Column Index)
------------------------------------
CREATE INDEX idx_column1_column2
ON table_name(column1, column2);
Example: If you often query by both last_name and first_name:

CREATE INDEX idx_last_name_first_name
ON customers(last_name, first_name

Unique Index
-------------------
A unique index ensures that no two rows have the same value in the indexed column(s).
CREATE UNIQUE INDEX idx_unique_column_name
ON table_name(column_name);
Example: If the email column in the customers table should be unique:

CREATE UNIQUE INDEX idx_unique_email
ON customers(email);

Full-Text Index
--------------------
Full-text indexes are used for full-text searches and are typically used on large text columns.

CREATE FULLTEXT INDEX idx_fulltext_column_name
ON table_name(column_name);
Example: If you have a products table with a description column, and you want to search through descriptions:

CREATE FULLTEXT INDEX idx_fulltext_description
ON products(description);

3. Dropping an Index
------------------------
To remove an index when it's no longer needed:

DROP INDEX idx_name ON table_name;
Example:
DROP INDEX idx_last_name ON customers;

clustered index
----------------------
A clustered index is a type of index in a database that directly affects the physical order of data in the table. In a table with a clustered index, 
the rows are stored in the same order as the index. This means that there can be only one clustered index per table because there can be only one physical 
order of the data.

Key Concepts of Clustered Index
	1. Physical Order: The rows in the table are stored on disk in the same order as the clustered index. This can make data retrieval very fast,
especially for range queries.
	2. Primary Key: In many databases, the primary key is automatically a clustered index by default. This is because primary keys are often used in 
queries, and having them as clustered indexes speeds up these operations.
	3. One Per Table: Since the clustered index defines the physical order of the table, you can only have one clustered index per table.
	4. Improved Performance: Clustered indexes are especially efficient for queries that return a range of values, as the data is physically stored 
in the order of the index.

Creating a Clustered Index
To create a clustered index, you specify the CLUSTERED keyword when creating the index. 

Advantages of Clustered Indexes
	1. Faster Data Retrieval: Because the rows are stored in order, clustered indexes significantly improve the performance of queries that retrieve a range of data or sort data by the index column(s).
	2. Efficient for Range Queries: Queries like SELECT * FROM table WHERE column BETWEEN x AND y are much faster with a clustered index.
	3. Primary Key as Clustered Index: Having the primary key as the clustered index makes it faster to retrieve rows based on their primary key.

Disadvantages of Clustered Indexes
	1. Slower Insert/Update/Delete: Since the physical order of the rows must be maintained, operations that change the data can be slower.
	2. Disk Space: Clustered indexes can lead to more fragmentation and may require additional storage.
	3. Only One Per Table: Since a table can only have one clustered index, careful consideration is needed when choosing the column(s) to index.
When to Use a Clustered Index
	• Primary Key: Most tables should have their primary key as the clustered index.
	• Frequent Range Queries: If your queries often retrieve a range of values (e.g., dates), a clustered index on the relevant column is beneficial.
	• Sorting Requirements: If you frequently need to sort the data by a specific column, a clustered index on that column can improve performance.
	
Example Scenario: Optimizing a Table with Clustered Index
Consider a transactions table with columns transaction_id, user_id, transaction_date, and amount. If most of your queries filter by transaction_date,
creating a clustered index on this column can improve performance:

How can remove defualt clustured index on primarykey  in any database	
---------------------------------------------------------------------------------------------------
o remove the clustered index on the primary key in a database system where the primary key is automatically created as a clustered index (such as SQL Server), you'll typically need to:
	1. Drop the primary key constraint.
	2. Recreate the primary key as a non-clustered index.
	3. Optionally, create a clustered index on a different column or columns if needed.
	
	• Dropping and Recreating the Primary Key: You drop the primary key to remove the automatic clustered index and then recreate it as a non-clustered index.
	• Optional Clustered Index: You can create a clustered index on a different column if needed, but this is optional.

non-clustered
	
A non-clustered index in a database is a type of index that maintains a separate structure from the table data. While a clustered index determines the physical order of data in the table (i.e., the data is stored in the same order as the index), a non-clustered index creates a logical ordering of data that is different from the physical order of rows.

Characteristics of a Non-Clustered Index:
Separate Structure: A non-clustered index has a separate structure from the actual table data. It contains pointers or references to the physical data rows rather than the data itself.
Multiple Non-Clustered Indexes: You can have multiple non-clustered indexes on a table, unlike the clustered index, where there can only be one per table.
Logical Ordering: The data is stored in one place, and the index is stored in another. The index will point to the location of the data rows, allowing for efficient lookups.
Structure of a Non-Clustered Index:
Index Key: The columns that are part of the non-clustered index are known as the index key.
Row Locator: In a non-clustered index, each entry includes a pointer to the actual data row. This pointer could be a row identifier (RID) in a heap or a clustered index key if the table has a clustered index.
Creating a Non-Clustered Index
In SQL, you can create a non-clustered index using the CREATE INDEX statement. Here's how you can do it in Oracle Database:

CREATE INDEX index_name 
ON table_name (column_name);
Example:
Let's say you have a table Employees with the following structure:

CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    FirstName VARCHAR(50),
    LastName VARCHAR(50),
    DepartmentID INT
);
You might want to create a non-clustered index on the LastName column to speed up queries that filter or sort by LastName.

CREATE INDEX idx_lastname 
ON Employees (LastName);
How Non-Clustered Index Works:
When you execute a query that filters data based on the LastName column:


SELECT * 
FROM Employees 
WHERE LastName = 'Smith';
The database engine uses the non-clustered index idx_lastname to quickly find all records where LastName = 'Smith'. The index provides a list of pointers to the rows in the actual table data. 
The engine then retrieves the corresponding rows from the table using these pointers.

Advantages of Non-Clustered Indexes:
Improves Query Performance: Non-clustered indexes can significantly improve the performance of queries, especially those that involve searching, sorting, or filtering.
Multiple Indexes: Since you can create multiple non-clustered indexes on a table, you can optimize queries for different columns.
Flexibility: Non-clustered indexes can be created on columns that are not part of the primary key, providing flexibility in optimizing queries based on different needs.

Disadvantages of Non-Clustered Indexes:
Additional Storage: Non-clustered indexes require additional storage since they are separate from the actual table data.
Maintenance Overhead: Indexes need to be maintained, which can introduce overhead during insert, update, and delete operations.


stored procedure
---------------------
A stored procedure is a set of SQL statements that can be stored in the database and executed as a unit. Stored procedures are typically used to 
encapsulate logic that can be reused across multiple applications or queries, improving performance and reducing redundancy.

Key Features of Stored Procedures:
Precompiled Execution: Stored procedures are compiled once and then stored in the database, allowing for faster execution compared to ad-hoc queries.
Modular Programming: Stored procedures allow developers to break down complex logic into manageable, reusable components.
Security: Access to data can be controlled by granting permission to execute the procedure without granting direct access to the underlying tables.
Reduced Network Traffic: Since the logic is executed on the server, the amount of data sent over the network can be reduced.
Structure of a Stored Procedure:
A stored procedure typically includes the following components:

Procedure Name: The name used to call the procedure.
Parameters: Input, output, and input/output parameters can be passed to and from the procedure.
SQL Statements: The body of the procedure, which can include queries, control-of-flow statements, and more.
Syntax for Creating a Stored Procedure in SQL:
Here is the general syntax for creating a stored procedure in an SQL database like Oracle:

CREATE [OR REPLACE] PROCEDURE procedure_name 
  [ (parameter_1 [IN | OUT | IN OUT] datatype, 
     parameter_2 [IN | OUT | IN OUT] datatype, 
     ...
   ) ]
AS
BEGIN
  -- SQL statements
END;
Example of a Stored Procedure:
Let's consider a stored procedure in Oracle that retrieves the total salary of all employees in a specific department.

CREATE OR REPLACE PROCEDURE GetTotalSalaryByDept (
    p_dept_id IN Employees.DepartmentID%TYPE,
    p_total_salary OUT NUMBER
) 
AS
BEGIN
    SELECT SUM(Salary)
    INTO p_total_salary
    FROM Employees
    WHERE DepartmentID = p_dept_id;
END;

Explanation:
GetTotalSalaryByDept: The name of the stored procedure.
p_dept_id: An input parameter that takes the department ID for which we want to calculate the total salary.
p_total_salary: An output parameter that will store the calculated total salary.
How to Execute a Stored Procedure:
You can execute a stored procedure using the EXEC or CALL statement.

DECLARE
  v_total_salary NUMBER;
BEGIN
  GetTotalSalaryByDept(10, v_total_salary);
  DBMS_OUTPUT.PUT_LINE('Total Salary: ' || v_total_salary);
END;


Explanation:
The procedure GetTotalSalaryByDept is called with 10 as the department ID.
The total salary for department 10 is returned in the v_total_salary variable.


Benefits of Using Stored Procedures:
Performance: Since they are precompiled, stored procedures can execute faster than dynamic SQL queries.
Reusability: Stored procedures can be reused across different applications, promoting code reuse.
Maintainability: Centralizing business logic in stored procedures makes it easier to update and maintain.
Security: Stored procedures can encapsulate sensitive business logic and limit direct access to the underlying tables.
Conclusion:
Stored procedures are a powerful tool for encapsulating and reusing complex logic within a database. They offer performance benefits, improve code 
maintainability, and can enhance security by controlling access to data. Using stored procedures, developers can create modular, reusable components that
can be invoked from different parts of an application, making database management more efficient.
Joins


normalization
triggers


