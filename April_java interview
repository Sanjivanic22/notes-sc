
core java questions and ans
==============================
1)Difference between final,finalize and finally
Can you explain the memory management in java and changes in java 8
JVm automatically manages the memory and its devided into into multiple
heap menmory,stack memory,method area and native memory
Heap memory -the heap is runtime data where where objects are stored
stack memory -the stack stores premitive types,method calls and local variable
method area-stores class metadata such as class names,fileds and methods

native memory-used yo store native code such as ccode and is not directly managed by JVM
Garbage collection 
jVM uses garbage collection to aumatically reclaimmemory occupied by object that are no longer reachable
G1 garbage collector which is designed to reduce pause time
In java 8 several changes done
Removal of permGen
metaspace 
natve memory tracking 
imprkoved garbage collector
3)what are the oops principle 
Encapsulation 
abstraction 
diff b/w them

what is diff b/w encapsulation and abstractions
Aspect	     Encapsulation	                                                              Abstraction
Definition	Bundles data and methods into a class and restricts direct access to fields.	Hides implementation details and shows only essential features.
 Purpose	Protects internal data and controls access.	                          Simplifies complexity by focusing on what an object does.
  Focus         	Securing and controlling access to data.	                               Simplifying interaction by hiding details.
Implementation	Achieved using private fields and public getters/setters.              	Achieved using abstract classes, interfaces, and abstract methods.
Visibility	   Controlled via access modifiers (private, public, etc.).	                  Hides internal logic; user only sees relevant features.

Polymorphism 
Inheritance

what is diff b/w abstract and interface
=========================================
Abstract Class
27. Definition: An abstract class is a class that cannot be instantiated and may contain abstract methods (methods without a body) as well as concrete methods (methods with a body).
28. Usage: Used to share common code among related classes.
29. Inheritance: A class can extend only one abstract class (single inheritance).
30. Members: Can have fields, constructors, and methods (both abstract and concrete).
31. Access Modifiers: Can use all access modifiers (public, protected, private).
nterface
32. Definition: An interface is a reference type that can contain only abstract methods (until Java 8, when default and static methods were introduced) and constants.
33. Usage: Used to define a contract that classes must follow.
34. Inheritance: A class can implement multiple interfaces (multiple inheritance).
35. Members: Can have abstract methods, default methods, static methods, and constants.
36. Access Modifiers: Methods are implicitly public and abstract; fields are implicitly public, static, and final.

Solid principle

can we overload static method?
yes
Stringbuilder vs Stringbuffer
===============================
StringBuffer
Thread-Safe: StringBuffer is synchronized, meaning it is thread-safe. Multiple threads can access it without causing data inconsistency.
Performance: Due to synchronization, StringBuffer is slower than StringBuilder when used in a single-threaded environment.
Usage: It is suitable for use in multi-threaded environments where thread safety is a concern.
StringBuilder
Not Thread-Safe: StringBuilder is not synchronized, meaning it is not thread-safe. It should not be used in multi-threaded environments without external synchronization.
Performance: StringBuilder is faster than StringBuffer because it does not have the overhead of synchronization.
Usage: It is suitable for use in single-threaded environments where performance is critical.

how we can handle concurrentmodificationException.
==================================================
oncurrentModificationException occurs when a collection is modified while iterating over it using iterators, enhanced for-loops, or other methods 
that are not designed for concurrent modification. Here are some ways to handle or avoid this exception:
1. Using Iterator's remove Method
Instead of modifying the collection directly, use the remove method of the Iterator:
2. Using CopyOnWriteArrayList
For concurrent modifications, use thread-safe collections like CopyOnWriteArrayList:
Absolutely! CopyOnWriteArrayList is a thread-safe variant of ArrayList provided in the java.util.concurrent package. 
It is designed for use in concurrent environments where read operations 
are more frequent than write operations. Here are some key points about CopyOnWriteArrayList:

3. Using synchronized Block
Synchronize the block of code that modifies the collection:
4. Using Stream API
Use the Stream API to filter out elements and collect the result into a new list:

diff between Collection and stream.
======================================
Collections are used for storing and managing groups of elements.
Streams are used for processing sequences of elements in a functional style.

comparable vs comparator
==========================
Comparable:

Defines natural ordering within the class itself.
Only one compareTo method can be implemented per class.
Used when a single default sorting order is needed.
Comparator

Defines custom ordering outside the class.
Multiple Comparator implementations can be created for different sorting criteria.
Used when multiple sorting orders are needed or when you cannot modify the class.
when we override equal method and hashcode
Custom Equality Logic: When you need to define custom logic for comparing objects based on specific attributes rather than their memory addresses.
Hash-Based Collections: When you plan to use your objects in hash-based collections, ensuring that objects considered equal have the same hash code.

why we use throw if exception can be handle usig try catch
=============================================================
Reasons to Use throw:
Propagating Exceptions: Sometimes, you might want to propagate an exception to a higher level in the call stack rather than handling it immediately. 
This allows the calling method to handle the exception or propagate it further.
Custom Exceptions: You can create and throw custom exceptions to signal specific error conditions in your application. 
This makes your code more readable and maintainable.
Separation of Concerns: By throwing exceptions, you can separate the logic of detecting errors from the logic of handling them. 
This can make your code cleaner and easier to understand.
Fail-Fast Principle: Throwing exceptions immediately when an error condition is detected can help you identify and fix issues early in the development process.


Collections
==============
1)what are the collections you used in your project 
List Set map
what is diff b/w araylist and linkedlist
Explain the differences between ArrayList and LinkedList.
==========================================================
ArrayList
Internal Structure:

ArrayList is backed by a dynamic array.
Elements are stored in contiguous memory locations.
Performance Characteristics:

Access Time: Fast (O(1) complexity) for accessing elements by index because it uses direct array indexing.
Insertion and Deletion: Slower (O(n) complexity) for inserting or deleting elements, especially in the middle of the list, because elements need to be shifted.
Memory Usage: May use more memory than necessary due to capacity resizing. When the array reaches its capacity, it is resized by creating a new array and copying the elements.
Use Cases:

Suitable for scenarios where frequent access to elements by index is required.
Ideal for read-heavy operations.

LinkedList
Internal Structure:

LinkedList is backed by a doubly-linked list.
Each element (node) contains a reference to the previous and next node.
Performance Characteristics:

Access Time: Slower (O(n) complexity) for accessing elements by index because it requires traversal from the beginning or end of the list.
Insertion and Deletion: Faster (O(1) complexity) for inserting or deleting elements at the beginning or end of the list, and generally faster
 for operations in the middle of the list because it only involves updating node references.
Memory Usage: Uses more memory per element due to the storage of additional references (previous and next nodes).
Use Cases:

Suitable for scenarios where frequent insertions and deletions are required.
Ideal for write-heavy operations.

internal working of Hashmap
===========================
A `HashMap` in Java works internally using an array of buckets to store key-value pairs. Here’s a brief overview of its internal workings:

### 1. **Hashing**
When you add a key-value pair to a `HashMap`, the key is hashed using the `hashCode()` method. This hash code is then used to determine 
the bucket index where the entry should be stored.

### 2. **Buckets**
The `HashMap` uses an array of buckets. Each bucket can hold multiple entries, which are stored as linked lists. 
This is necessary to handle hash collisions (when multiple keys hash to the same bucket).

### 3. **Entry Storage**
Each entry in the `HashMap` is stored as an instance of the `Node` class, which contains the key, value, hash code, and a reference to the next node
(for handling collisions).

### 4. **Collision Handling**
When a collision occurs (i.e., multiple keys hash to the same bucket), the entries are stored in a linked list within that bucket. 
If the linked list becomes too long, it may be converted to a balanced tree (red-black tree) to improve performance.

### 5. **Retrieval**
To retrieve a value, the `HashMap` hashes the key to find the appropriate bucket. It then traverses the linked list (or tree) in that bucket to find the matching key and return the associated value.

### 6. **Rehashing**
When the `HashMap` exceeds a certain load factor (default is 0.75), it automatically resizes itself by doubling the number of buckets and rehashing all existing entries to distribute them across the new array.



Concurrent hashmap
what is diferance b/w hashmap and concurrent hashmap
how to handle Concurrecy in java
Handling concurrency in Java involves managing multiple threads to ensure that they operate correctly and efficiently without causing data inconsistencies
 or other issues. Here are some key concepts and tools for handling concurrency in Java:

1. Synchronized Methods and Blocks
Use the synchronized keyword to control access to critical sections of code, ensuring that only one thread can execute them at a time.

2. Locks
Java provides more flexible locking mechanisms through the java.util.concurrent.locks package, such as ReentrantLock.
3. Atomic Variables
Use atomic variables from the java.util.concurrent.atomic package for lock-free thread-safe operations on single variables.
4. Concurrent Collections
Java provides thread-safe collections in the java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, and BlockingQueue.
5. Executors and Thread Pools
Use the ExecutorService framework to manage a pool of threads, simplifying the process of managing thread lifecycles.

Multithreading 
================
how to implement Multthreading
Summary:
Extending Thread Class: Create a new thread by extending Thread and overriding run.
Implementing Runnable Interface: Implement Runnable and pass it to a Thread object.
Using ExecutorService: Manage a pool of threads with ExecutorService.
Synchronization: Use synchronization to avoid race conditions and ensure thread safety.

what is deadlock and Race constion and how to overcome?
A Deadlock is situation where two or more more threads are unbale to proceed because each is waiting for other to release resource.
*Example of Deadlock*
Suppose we have two threads, T1 and T2, and two resources, R1 and R2.
 
1. T1 locks R1 and waits for R2.
2. T2 locks R2 and waits for R1.
 
In this situation, both threads are waiting for each other to release resources, resulting in a deadlock.
# Race Condition
A race condition is a situation where the behavior of a program depends on the relative timing of threads.
 
*Example of Race Condition*
Suppose we have two threads, T1 and T2, that are incrementing a shared variable, x.
 
1. T1 reads the value of x (x = 0).
2. T2 reads the value of x (x = 0).
3. T1 increments the value of x (x = 1).
4. T2 increments the value of x (x = 1).
# Prevention Techniques
*Deadlock Prevention*
1. Avoid nested locks.
2. Use lock timeouts.
3. Establish a lock ordering mechanism.
 
*Race Condition Prevention*
1. Use synchronization mechanisms (e.g., locks, semaphores).
2. Use atomic operations.
3. Avoid shared variables.

1) What is submit and execute command do
	Submit Command:
	• Purpose: The submit method is used to submit a task for execution and returns a Future object. 
This Future can be used to retrieve the result of the computation, handle exceptions, and monitor the status of the task.
	
• Key Point: The submit method is useful when you need to get the result of the task or manage its execution

.
1. Execute Command:
• Purpose: The execute method is used to execute a task but does not return a Future. It is typically used for tasks that do not need to return a result or be monitored.

Key Point: The execute method is simpler and is used for tasks where you do not need to track the outcome

Which is better between Thread and Runnable and why

What is Reentrant Lock
=============================
A **ReentrantLock** is a type of lock provided by the `java.util.concurrent.locks` package in Java 
that allows threads to enter a lock they already hold. This means that if a thread has acquired the lock, it can re-enter the lock without being blocked,
 which is useful for implementing synchronized methods or blocks.

### Key Features of ReentrantLock

1. **Reentrancy**: A thread can acquire the lock multiple times without blocking itself.
2. **Fairness**: You can create a fair lock that grants access to threads in the order they requested it.
3. **Lock Methods**: Provides methods for locking, unlocking, and checking the lock status.

Syncronization and class level lock and which method release the lock

java 8 features
=====================
wht are the features
Lambda Expressions: These allow you to write more concise and readable code by enabling functional programming.
Stream API: This provides a powerful way to process sequences of elements, making it easier to perform operations like filtering, mapping, and reducing.
Intermediate Operations
=============================
Intermediate operations return a new stream and are used to transform or filter the elements of the stream.
 These operations are lazy, meaning they do not process the elements until a terminal operation is invoked. 
Intermediate operations can be chained together to form a pipeline.

Common intermediate operations include:
filter: Filters elements based on a predicate.
map: Transforms each element using a function.
flatMap: Transforms each element into a stream and flattens the result.
distinct: Removes duplicate elements.
sorted: Sorts the elements.
peek: Performs an action on each element without modifying the stream.
Example:

List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());

Terminal Operations

Terminal operations produce a result or a side-effect and mark the end of the stream pipeline. 
Once a terminal operation is invoked, the stream is considered consumed and cannot be reused.

Common terminal operations include:

collect: Converts the stream into a collection or another data structure.
forEach: Performs an action for each element.
reduce: Combines elements to produce a single result.
count: Returns the number of elements in the stream.
anyMatch: Returns true if any element matches the given predicate.
allMatch: Returns true if all elements match the given predicate.
noneMatch: Returns true if no elements match the given predicate.
findFirst: Returns the first element in the stream.
findAny: Returns any element in the stream.
Example:

List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
long count = names.stream()
    .filter(name -> name.length() > 3)
    .count();

}
In this example, filter is an intermediate operation, and count is a terminal operation.
 The stream pipeline processes the elements only when the terminal operation count is invoked.

Default Methods: 
=================
Default methods are defined in interfaces using the default keyword.
They provide a default implementation that can be overridden by implementing classes.
Interfaces can now have default methods with implementations, allowing for more flexible and backward-compatible code.

Optional Class: This helps in handling null values more gracefully, reducing the risk of NullPointerException.

New Date and Time API: A comprehensive and modern API for date and time manipulation, replacing the old java.util.Date and java.util.Calendar.
Immutability: The new date and time classes are immutable and thread-safe.
Fluent API: Provides a fluent API for constructing and manipulating date and time objects.
Better Time Zone Support: Improved support for time zones and offsets.
Date and Time Arithmetic: Simplified date and time arithmetic operations.

Nashorn JavaScript Engine: A new engine for executing JavaScript code within Java applications.

Method References: These provide a way to refer to methods without invoking them, making code more readable and concise.
Type Annotations: These allow annotations to be used in more places, such as on generic types.

what is functional interface and examples 
A functional interface in Java is an interface that has exactly one abstract method. These interfaces are used primarily for lambda expressions and method references, 
enabling a more functional programming style in Java. Functional interfaces can have multiple default or static methods, but only one abstract method.
Key Points:
Single Abstract Method: A functional interface has exactly one abstract method.
Lambda Expressions: Functional interfaces are the target types for lambda expressions.
Annotation: The @FunctionalInterface annotation can be used to indicate that an interface is intended to be a functional interface, although it's not mandatory
Ex.Runnable ,callable and comparable 
1. Runnable Interface
The Runnable interface is a functional interface with a single abstract method run.
@FunctionalInterface
public interface Runnable {
    void run();
}
Example Usage:
Runnable runnable = () -> System.out.println("Running in a thread");
new Thread(runnable).start();

2. Comparator Interface
The Comparator interface is a functional interface with a single abstract method compare.

@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
Example Usage:
Comparator<String> comparator = (s1, s2) -> s1.compareTo(s2);
int result = comparator.compare("apple", "banana");
System.out.println("Comparison result: " + result);

Predefined functional interface
==================================
Java 8 introduced several predefined functional interfaces in the java.util.function package. These interfaces are designed to support functional programming and can be used with lambda expressions and method references.
1 .Predicate
1. Predicate
Represents a boolean-valued function of one argument.
Example:
import java.util.function.Predicate;
public class PredicateExample {
    public static void main(String[] args) {
        Predicate<String> isLongerThan5 = str -> str.length() > 5;
        System.out.println(isLongerThan5.test("Hello")); // Output: false
        System.out.println(isLongerThan5.test("Hello, world!")); // Output: true
    }

2. Function<T, R>
Represents a function that accepts one argument and produces a result.
Example:
import java.util.function.Function;
public class FunctionExample {
    public static void main(String[] args) {
        Function<String, Integer> stringLength = str -> str.length();
        System.out.println(stringLength.apply("Hello")); // Output: 5
    }
}
3. Consumer
Represents an operation that accepts a single input argument and returns no result.
Example:
import java.util.function.Consumer;
public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> print = str -> System.out.println(str);
        print.accept("Hello, world!"); // Output: Hello, world!
    }
}
4. Supplier
Represents a supplier of results.
Example:
import java.util.function.Supplier;
public class SupplierExample {
    public static void main(String[] args) {
        Supplier<String> supplier = () -> "Hello, world!";
        System.out.println(supplier.get()); // Output: Hello, world!
    }
}
5. UnaryOperator
Represents an operation on a single operand that produces a result of the same type as its operand.
Example:
import java.util.function.UnaryOperator;
public class UnaryOperatorExample {
    public static void main(String[] args) {
        UnaryOperator<Integer> square = x -> x * x;
        System.out.println(square.apply(5)); // Output: 25
    }
}
6. BinaryOperator
Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
Example:
import java.util.function.BinaryOperator;
public class BinaryOperatorExample {
    public static void main(String[] args) {
        BinaryOperator<Integer> add = (a, b) -> a + b;
        System.out.println(add.apply(5, 3)); // Output: 8
    }
}

what is the diff b/w Runnable and Callable
Runnable: Used for tasks that do not need to return a result or handle checked exceptions.
Callable: Used for tasks that need to return a result or handle checked exceptions.
Runnable: Cannot throw checked exceptions.
Callable: Can throw checked exceptions.

why default method allowed in function interface.
Default methods in functional interfaces allow for backward compatibility, enhanced functionality, and flexibility in API design. 
They enable interfaces to evolve without breaking existing implementations and provide additional utility methods that can be used by all implementing classes.

how we can achieve muliple inheritance in java 8.
stream api find maximum salary of employee.


can we replace @service with @component and vise versa?
Yes 
	Spring:
===============
	- What’s Spring framework & advantages-done
	## Spring 
-=================
Spring is opensource lightweight framework 
Which is used to develop any kind of application
It is like framework of framework because it support vrious framework like struts and hibernate.
Spring framework comprise several modules such as IOC,AOP,springn core,spring mvc

Advantages
==========
Spring framework provides predefined libraries and templates
Spring framework privide loos coupling
Manages the dependancies injection and IOC automatically
Spring framwork very easy to  testing
Spring web framework is well design mvc framework which provide the greate alteranative to another ````framework like struts.

Spring container
===================
Spring container is at the core of the spring framework.
The container will creates the object,wire them together,configure them and manage their complete life cycle from creation till destruction.
the spring container uses DI to manage the componenets that make up an application.


IOC container and types
=========================
IOC container
======================
The IOC container is INVERSION of control which is responsible to instantiate, configure and assemble the objects. 
The IoC container gets informations from the XML file and works accordingly. 
The main tasks performed by IoC container are:
=>to instantiate the application class
=>to configure the object
=>to assemble the dependencies between the objects

There are two types of IoC containers. They are:
==================================================
1)BeanFactory
2)ApplicationContext

In the spring both BeanFactory and ApplicationContext are interfaces used for managing beans. 

Difference between BeanFactory and the ApplicationContext
==================================================================

Using BeanFactory
=====================

Xml beanfactory is implementation class to use the bean factory for that we need to create the instance of xmlbeanfactory.
 To use the BeanFactory, we need to create the instance of XmlBeanFactory class as given below:

Resource resource=new ClassPathResource("applicationContext.xml");  
BeanFactory factory=new XmlBeanFactory(resource); 
 
The constructor of XmlBeanFactory class receives the Resource object so we need to pass the resource object to create the object of BeanFactory.
Using ApplicationContext
=============================
the ApplicationContext interface is built on top of the BeanFactory interface. 
It adds some extra functionality than BeanFactory such as simple integration with Spring's AOP, message resource handling (for I18N), event propagation, application layer specific context (e.g. WebApplicationContext) for web application.
 So it is better to use ApplicationContext than BeanFactory.
The ClassPathXmlApplicationContext class is the implementation class of ApplicationContext interface.
 
We need to instantiate the ClassPathXmlApplicationContext class to use the ApplicationContext as given below:

ApplicationContext context =   
    new ClassPathXmlApplicationContext("applicationContext.xml"); 

The constructor of ClassPathXmlApplicationContext class receives string, so we can pass the name of the xml file to create the instance of ApplicationContext.

spring bean life cycle
==========================
spring bean life will start from the bean creation and end with bean destruction
init and destry methods are impiratant in spring bean life cycle which can configure in xml file with init-initailization and 
init-destruction .or programatically we can do with @ initailization and @disposable method

Spring bean life cycle is maintained by IOC Container

1. Container gets started.

2. Container creates the object of bean as per request.

3. Dependencies is created

4. Dependencies is injected

5. Destroyed when container closed.

Dependancy injection
======================
Depenancy injection is design pattern thet removes the dependancies  from the programming code so that it can be easy to test and manage the application.
Dependancy injection makes our code loosely coupled.

Constructor injection
=======================
Here Our Ioc container uses parameterised constructor to create the target bean class object.
In that process we inject the dependant class object to target class object.

The <constructor-args> tag is used for constructor injection.
Here we inject the 
Primitive and string based value
Dependant object
Collection values
If all properties of spring bean class are mandatory to participate in the injection then we 
Should go for constructor injection.

Settter injection
===========================
Here IOC container calls the setter of target class to assign dependant class object to target class object.
<property>tag used for setter injection

Key Differences
Setter Injection:

More flexible as dependencies can be changed after the object is created.
Allows for partial injection.
Easier to manage circular dependencies.
Constructor Injection:

Ensures that all required dependencies are provided at the time of object creation.
Makes the object immutable after creation.
Better for mandatory dependencies.

If we want to involve only our choice of propetries into the spring class the we should go for setter injection.


Spring bean scope
===================
In Spring, "scope" refers to the lifecycle of a bean, defining how long a bean instance should live and how it should be created and shared within 
the application context.
Spring provides several scopes to manage the lifecycle and visibility of beans. Here are the common bean scopes available in Spring:

Singletone
===========
If scope is set to singletone scope ,the spring IOC container creates exactly one instance of the object defined by that bean defination.
It is default scope if no scope is specified
IOC container creates only one oject for spring bean class nad reuses that object.

Prototype
=============
If scope is set to prototype ,the spring IOC container creates a new instance of the object.
 every time a resquest for that specific bean is mode as rule 
use the prototype scope for all state-full beans and singletom scope for stateless beans.
To define prototype ,you can set the  scope property to prototype in the bean configuration file.

Scope=Request (for http protocol)
================================
bean instance will created per http request
Scope="session"
Ioc container keeps spring bean class object as session attribute of web app env.
bean instance will be created per http session

Global session

Autowring
=============
Autowiring is a feature in Spring Framework that allows Spring to automatically inject dependencies into a bean. 
This helps to reduce the need for explicit configuration and makes the code cleaner and easier to manage..
Modes of autowiring
No
Default autowiring mode,its mean no autowiring by default.

Byname
--------
Inject the onject dependancy.according to proptery name and bean name.
In this case proptery name bean name must be same internally call setter method .

Bytype
---------
Inject the object dependancy according to type property name and bean name can be different.
Internally call setter method.

Constructor
------------
Inject by calling constructor of class calls constructor having the large no of parameter.
Autodected-deprecated.

Spring Transaction in spring
=============================
In spring transaction can be handle in two ways.
i.e Programatically and declaratively
1) in programatic we have to write series of code  to commit your transaction and rollback transaction.
that means we need to write for commit or rollback transaction
there is one more way that is declarative way where we write template in xml
whenever the is runtime exception the spring will automatically rollback the transaction and if there no exception then spring will commit the transaction.
Spring ORM
============
It is a spring module providing abstraction on multiple ORM frameworks like hiberante,iBatis and etc to simplify Object based O-R mapping persistance logic.

It supplies mutiple templates classes like hibernate template 

How can we disable configuration in spring?
============================================
To disable auto-configuration for a specific class or feature in a Spring Boot application, you can use the @EnableAutoConfiguration annotation 
along with the exclude attribute. This allows you to exclude specific auto- configuration classes from being applied.

@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, MultipartAutoConfiguration.class}}

- Difference between independent Singleton object & Spring Singleton Bean
===========================================================================	
Independent Singleton Object:
Definition: A Singleton object is a design pattern that ensures a class has only one instance and provides a global point of access to that instance.
Implementation: Typically implemented using a private constructor, a static instance variable, and a public static method to return the instance.
Lifecycle: The lifecycle of the Singleton object is managed manually by the developer. The instance is created when first accessed and remains in memory for the duration of the application.
Scope: The Singleton object is application-wide, meaning it is shared across the entire application.

Spring Singleton Bean:
Definition: A Spring Singleton Bean is a bean managed by the Spring container that is defined with a singleton scope. This means that only one instance of the bean is created and shared within the Spring container.
Implementation: Configured using Spring's XML configuration or annotations (@Bean, @Scope("singleton")).
Lifecycle: The lifecycle of the Singleton Bean is managed by the Spring container. The instance is created when the container is initialized and remains in memory for the duration of the container's lifecycle.
Scope: The Singleton Bean is container-wide, meaning it is shared within the Spring container but not necessarily across the entire application if multiple containers are used.
	- What's limitations of autowiring

can we use @compoenet in repository class and can we use @repository in component 
==================================================================================
Yes, you can use @Component in a repository class and @Repository in a component class, but there are specific reasons and best practices for using each annotation.
@Component:
Generic Annotation: @Component is a generic stereotype annotation indicating that the class is a Spring-managed component.
Usage: It can be used on any Spring-managed bean, including service, repository, and controller classes.
@Repository:
Specialized Annotation: @Repository is a specialized stereotype annotation indicating that the class is a Data Access Object (DAO). 
It provides additional features such as exception translation.
Usage: It is typically used on classes that interact with the database, such as repository classes.
 
springboot
=======================
how to secure end point from URL using spring restful services
Securing endpoints in Spring RESTful services is crucial to protect your application from unauthorized access and potential security threats.
1. Use HTTPS
Ensure that your application uses HTTPS to encrypt communication between the client and server.
This prevents data from being intercepted during transmission.

2. Spring Security Configuration
Extend the WebSecurityConfigurerAdapter class and override its methods to configure security settings.
3. Role-Based Access Control
Use role-based access control to limit access to sensitive resources based on user roles.
4. **JWT stateless authentication. This involves generating a token upon successful login and validating it for subsequent requests.

2)WHAT IS jwt HOW TO IMPLEMENT AND VALIDATE
===========================================
What is JWT?
JSON Web Token (JWT) is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object. 
It is commonly used for authentication and authorization in web applications. JWTs are compact, self-contained,
and can be signed and optionally encrypted to ensure the integrity and confidentiality of the information they contain12.

Structure of JWT
A JWT consists of three parts:
Header: Contains metadata about the token, such as the type of token and the algorithm used for signing.
Payload: Contains the claims, which are statements about an entity (typically the user) and additional data.
Signature: Ensures the token hasn't been altered. It is created using the header, payload, and a secret key.

Implementing JWT
To implement JWT in a Spring Boot application, follow these steps:

1. Add Dependencies
Add the necessary dependencies to your pom.xml file:
<artifactId>jjwt</artifactId>
    <version>0.9.1</version>
2. Create JWT Utility Class
Create a utility class to generate and validate JWT tokens:
3. Configure Spring Security
Configure Spring Security to use JWT for authentication:
4. Create Authentication Filter
Create a filter to validate JWT tokens:
Validating JWT
To validate a JWT, you need to:

Extract Claims: Parse the token and extract the claims.
Verify Signature: Ensure the token's signature matches the expected signature using the secret key.
Check Expiration: Verify that the token has not expired.

6) What are the issues you faced in production and how you handled
8) caching, qualifiers, circular reference, annotations , REST APIs 
	what if build stucked when PR creating.
	what key mecanism will be used to secure external API server.

What’s repository in Spring Data JPA
In Spring Data JPA, a repository is a central interface that provides a way to perform CRUD (Create, Read, Update, Delete) operations on entities without the need to write boilerplate code. It abstracts the data access layer and allows you to interact with the database in a more convenient and consistent manner.

Key
Common Repository Interfaces:
CrudRepository: Provides CRUD functionality.
Purpose: Provides basic CRUD (Create, Read, Update, Delete) operations.
Methods:
save(S entity): Saves a given entity.
findOne(ID id): Retrieves an entity by its ID.
findAll(): Returns all entities.
count(): Returns the count of entities.
delete(T entity): Deletes a given entity.
exists(ID id): Checks if an entity exists by its ID.

JpaRepository: Extends CrudRepository and PagingAndSortingRepository to provide additional JPA-specific methods.
flush(): Flushes all pending changes to the database.
saveAndFlush(S entity): Saves an entity and flushes changes immediately.
deleteInBatch(Iterable<T> entities): Deletes the given entities in a batch.

PagingAndSortingRepository: Adds methods for pagination and sorting.
findAll(): Returns all entities.
findAll(Sort sort): Returns all entities sorted by the given options.
findAll(Pageable pageable): Returns a paginated list of entities.

How we can use multiple database in the project
=====================================================
Using multiple databases in a Spring Boot project involves configuring multiple DataSource beans and setting up separate EntityManagerFactory 
and TransactionManager beans for each database. Here's a step-by-step guide to achieve this:

1. Add Dependencies
Ensure you have the necessary dependencies in your pom.xml file:
2. Configure DataSources
Define the configurations for each database in your application.properties or application.yml file.
3. Create Configuration Classes
Create separate configuration classes for each DataSource, EntityManagerFactory, and TransactionManager.
follow same process for secondary DB
4. Define Entity Classes and Repositories
Create entity classes and repositories for each database, ensuring they are in the correct packages.

What is AOP

Singleton, Factory and Abstract Factory Design pattern and where this Design pattern used in your project
==========================================================================================================
he Singleton design pattern is a creational design pattern that restricts a class from instantiating multiple objects. 
It creates a single instance of a class and provides a global point of access to that instance.
 
# Key Elements of Singleton Pattern
1. *Private Constructor*: The class has a private constructor to prevent instantiation from outside.
2. *Static Instance Variable*: The class has a static instance variable that holds the single instance of the class.
3. *Public Static Method*: The class has a public static method that provides access to the single instance.

The Factory design pattern is a creational design pattern that provides a way to create objects without specifying the exact class of object that will be created.
In a real-world project, these design patterns can be used in various scenarios, such as:

The Abstract Factory pattern is a creational design pattern that provides a way to create families of related objects without specifying their concrete classes.
 
- A web application that uses a Singleton logger to log messages across the application.
- A database-driven application that uses a Factory to create database connections based on the database type.
- A UI application that uses an Abstract Factory to create UI components based on the UI theme.
What is strong reference, Soft Reference., Weak Reference and Phantom Reference
How you can implement second level cache in your project

@GeneratedValue used for
=============================
The @GeneratedValue annotation in Java is used to specify how the primary key value should be generated for an entity.
It is typically used in conjunction with the @Id annotation in JPA (Java Persistence API) to mark a field as the primary key 
and to define the strategy for generating unique values for that key.

Key Points:
Purpose: Automatically generate unique primary key values for entity instances.
Strategies:
AUTO: The persistence provider chooses the appropriate strategy for the database.
IDENTITY: The database generates the primary key value, typically using an auto-increment column.
SEQUENCE: Uses a database sequence to generate primary key values.
TABLE: Uses a table to generate primary key values.

 which HTTP method will be used for create and update at same time.
========================================================================
PUT: Used for both creating and updating a resource. It is idempotent and typically replaces the entire resource at the specified URI.

@bean used for?
The @Bean annotation in Spring is used to indicate that a method produces a bean to be managed by the Spring container.
It is typically used in configuration classes to define beans that are created and managed by Spring's Inversion of Control (IoC) container.

Key Points:
Bean Definition: Methods annotated with @Bean define beans that are registered with the Spring container.
Configuration Classes: Commonly used within classes annotated with @Configuration.
Customization: Allows for the customization of bean creation and initialization.

	how we can get value from properties file in springboot.
=========================================================
using @Value 
using @cnfiguration propertis
using =\ with list
using environment object

hoe we can find out that code is 80% coverge in sonarcube.
what is the best authentication can be used to handle security in payment method based application.
=====================================================================================================
1. Multi-Factor Authentication (MFA)
MFA involves verifying the user's identity using two or more independent factors:

Knowledge: Something the user knows (e.g., password, PIN).
Possession: Something the user has (e.g., smartphone, hardware token).
Inherence: Something the user is (e.g., biometric data like fingerprints or facial recognition).
2. Biometric Authentication
Biometric authentication uses unique biological traits to verify identity. Common methods include:

Fingerprint Scanning
Facial Recognition
Iris Scanning
Biometric authentication is highly secure and user-friendly1.

3. Token-Based Authentication
Token-based authentication involves generating a unique token for each session. This token is used to verify the user's identity and can be implemented using:

Hardware Tokens: Physical devices that generate one-time passwords.
Software Tokens: Applications that generate one-time passwords.
4. SMS OTP (One-Time Password)
SMS OTP sends a one-time password to the user's mobile device via text message. While convenient, it is vulnerable to SIM interception and phishing attacks2.

5. Strong Customer Authentication (SCA)
SCA, mandated by the PSD2 regulation, requires at least two authentication factors from the categories mentioned above. It provides an additional layer of security for online payments1.

6. Encryption and Tokenization
Encrypting sensitive data and using tokenization to replace sensitive information with non-sensitive tokens can significantly enhance security3.

how we can hit external url from application.
=================================================
To hit an external URL from a Spring Boot application, you can use the RestTemplate or WebClient classes provided by Spring
Using RestTemplate
RestTemplate is a synchronous client to perform HTTP requests. It's simple to use but is being phased out in favor of WebClient.
Using WebClient
WebClient is part of the Spring WebFlux module and supports both synchronous and asynchronous operations. 
It's the recommended way to perform HTTP requests in Spring Boot applications.

if there is multiple restcontroller in one application then how system will address that which controller needs to be called.
================================================================================================================================
In a Spring Boot application with multiple @RestController classes, the system determines which controller to call based on the URL mapping defined in each
controller. 
Each @RestController class defines one or more request mappings using annotations like @RequestMapping, @GetMapping, @PostMapping, etc. These annotations 
specify the URL patterns that the controller methods handle.
URL Mapping: Each controller defines URL patterns using annotations.
Routing: The system routes requests to the appropriate controller based on the URL.
Path Variables and Request Parameters: Controllers can handle specific requests using path variables and request parameters.

What is spring boot & its architecture -done
	
	- What are the advantages of spring boot-done
	- What’s the disadvantage of Spring boot-done

	- What’s the important configuration file in Spring boot
	application.properties file or application.yml file

	- What is Spring Boot and What Are Its Main Features?-done

	- What Are the Differences Between Spring and Spring Boot?-done

What is Spring Initializr?

What’s Actuator
Spring Boot Actuator is a powerful tool that provides production-ready features to help you monitor and manage your Spring Boot application. 
It exposes various endpoints that allow you to interact with your application and gather important metrics and information
 How to migrate existing project to Springboot?

	REST API:
==================
	- What is REST API
A REST API (Representational State Transfer Application Programming Interface) is a set of rules and conventions for building and interacting with web services.
It allows different systems to communicate over HTTP by following a set of principles and using standard HTTP methods.
	- What are HTTP methods supported by REST
	- What’s JAX-RS
	- What’s @RestController
	- Difference between SOAP & REST Webservices
	- What different output types supported by REST
	- How request payload from Client request gets mapped to @RequestBody object – Jackson library
	- Best practices for creating REST URI.
	- What’s @PathParameter
	- What’s are Idempotent methods
	- How to create/implement REST API
	- How to expose Restful webservice
	how to convert xml data into json
HTTP (HyperText Transfer Protocol)
• Purpose: Used for transmitting hypertext (web pages) over the internet.
• Security: Data is sent in plain text, making it vulnerable to interception and attacks.
• Port: Typically uses port 80.
• URL Prefix: URLs start with http://.
HTTPS (HyperText Transfer Protocol Secure)
• Purpose: Same as HTTP, but with added security.
• Security: Encrypts data using SSL/TLS, ensuring data integrity and confidentiality.
• Port: Typically uses port 443.
• URL Prefix: URLs start with https://.
In summary, HTTPS is the secure version of HTTP, providing encryption to protect data during transmission. This makes HTTPS essential for sensitive transactions, such as online banking and shopping.


Annotations
============

database
=========
what is the diff b/w primary key,unique key and foreign key

Primary Key
• Purpose: Uniquely identifies each record in a table.
• Uniqueness: Must be unique for each record.
• Null Values: Cannot contain NULL values.
• Example: In a students table, student_id can be a primary key.
Unique Key
• Purpose: Ensures all values in a column are unique.
• Uniqueness: Must be unique for each record.
• Null Values: Can contain a single NULL value (depending on the database system).
• Example: In a users table, email can be a unique key.
Foreign Key
• Purpose: Establishes a link between records in two tables.
• Uniqueness: Can have duplicate values.
• Null Values: Can contain NULL values.
• Example: In an orders table, customer_id can be a foreign key referencing customer_id in a customers table.

whta is index how it works
===================================
An index is a data structure that improves the speed of data retrieval operations on a database table. 
It works similarly to an index in a book, allowing you to quickly find the information you need without scanning every page.
what is diff b.w delet and truncate
=====================================
DELETE
Purpose: Removes specific rows from a table based on a condition.
Usage: Can be used with a WHERE clause to specify which rows to delete.
Transaction: Each row deletion is logged, making it slower but allowing for rollback if needed.
Example:
DELETE FROM employees WHERE department = 'Sales';
Triggers: Activates triggers associated with the table.
Constraints: Checks constraints and foreign key relationships.
TRUNCATE
Purpose: Removes all rows from a table, effectively resetting it.
Usage: Cannot be used with a WHERE clause; it always removes all rows.
Transaction: Minimal logging, making it faster but not allowing for rollback.

Microservices
================
## what is microservice architecture
-----------------------------------------
Microservice is an architectural style for designing and building software applications as a collection of small, independent, and 
loosely coupled servicesthat communicate with other over well defined API'S.  In this approach, an application is divided into a set of services, 
each representing a specific business capability and running as a separate process or container.

## what is diferance b/w Microservice and Monolithic architecture.
--------------------------------------------------------------------
Microservices                                                             
1)are small and focused on bussiness capabilities.
2)Microservices can developed,deployed and scaled independatly.allowing  for agility and flexibility.
3)microservices are allow to use of diffenert tecnology,programming language for each service depending on the specific requirement

 Monolithic
--------------
1)Monolthic are larger and contains all functionality in signle unit
2)monolithic requirs the entire application to be delpoyed and scale.d as whole
3) entire application is developed in single technology stack.

how microservice will communicate with each other
======================================================

Microservices can communicate with each other using various methods, each with its own benefits and trade-offs.  

1. HTTP/REST
Description: Microservices communicate over HTTP using RESTful APIs. Each service exposes endpoints that other services can call.
Example: Service A makes an HTTP GET request to Service B to retrieve some data.

2. Messaging (Asynchronous Communication)
Description: Microservices communicate by sending messages to each other via a message broker (e.g., RabbitMQ, Kafka).
Example: Service A publishes a message to a queue, and Service B consumes the message and processes it.
.
3. gRPC
Description: gRPC is a high-performance, open-source RPC framework that uses HTTP/2 for transport and Protocol Buffers for serialization.
Example: Service A calls a method on Service B using gRPC.

4. Event-Driven Architecture
Description: Microservices communicate by emitting and listening to events. An event bus or event streaming platform (e.g., Kafka) is used to publish and
 subscribe to events.
Example: Service A emits an event when a user is created, and Service B listens for this event to perform additional actions.

5. Service Mesh
Description: A service mesh (e.g., Istio) provides a dedicated infrastructure layer for handling service-to-service communication.
Example: Service A communicates with Service B through the service mesh, which handles load balancing, retries, and security.

What is Api gateways?
-----------------------
In microservice architerure an ApI gateway is server side componenet that acts as an entry point or facade for client application to access the 
underlaying microservices.
API gateway handle incoming client request and route them to the appropriate MS based the requested API endpoint.
it can handle the authentication and authorzation validate caces token.

we use AWS API Gateway, a fully managed service provided by Amazon Web Services that makes it easy to create, publish, maintain, monitor, and secure APIs 
at any scale.'"

What is cicuit braking and wh to y it is so important?
-------------------------------------------------------------
circuit breaking is mechanism use in microservice to improve the resillience and functinonality of the system.
it helps to prevent failure in once service from cascading and affecting the overall system to improve the system resilience
it enables services and client application to handle n/w and service disruption more effectively leading to more robust and reliable MS.

WHat is Eureka server?
=-----------------------
Eureka server is compoent of netflix,service discovery and resistration tool for building microservice based application.
eureka server acts as centralized registry where MS can register themselves and discover service within the system.
eureka servver server provides diffenet kind of functionality.
service registration
service discovery
load balancing
failover and fault tolarance

what is service descovery?
-----------------------------
in microservices Service discovery  enables the automatic detection of services within a microservice architecture. 
This process allows services to find and communicate with each other without hard-coding their network locations. 

Service Registry:
A central repository that maintains the list of service instances and their network locations (IP addresses and ports).
The service registry is updated dynamically as services start and stop.

What is load balanncer
----------------------------
A load balancer  is a component that distributes incoming network traffic across multiple service instances to ensure no single instance becomes a
 bottleneck. 
Load balancing enhances the reliability, availability, and scalability of microservices by managing the distribution of workloads and ensuring optimal 
resource utilization.

hystrix
===========
It helps to control the interactions between distributed services by adding fault tolerance logic, thereby ensuring that failures in one service
do not cascade and cause system-wide outages.
Hystrix helps in preventing cascading failures in a microservice architecture. 
If one service fails, it ensures that the failure does not propagate to other services by isolating the faulty service.

admin server
=================
In a microservices architecture, an admin server is used to manage and monitor the various microservices. 
One popular tool for this purpose is Spring Boot Admin, which provides a web UI to visualize the metrics and health of multiple Spring Boot applications.
<artifactId>spring-boot-admin-starter-server</artifactId> this dependancy need to add in pom.xml

Zipkin server
===============
Zipkin is a distributed tracing system that helps troubleshoot latency problems in service architectures by collecting and querying trace data. 
Setting up a Zipkin server allows you to visualize and analyze the performance of your microservices.
You can set up a Zipkin server using various methods, including Docker, Java, and Homebrew.
 
config server
================
A Config Server in a microservices architecture provides a centralized way to manage external configuration properties for applications across all environments. 
Spring Cloud Config Server is a popular choice for this purpose. 
spring-cloud-config-server dependencies.

feign client
Feign is a declarative web service client that simplifies the process of making HTTP requests in a microservices architecture. It allows you 
to define an interface for your REST client and automatically generates the implementation, making it easier to communicate between microservices.
 
security(JWT)
implementing JWT (JSON Web Token) security in a microservices architecture is a common approach to ensure secure communication and authentication \
between services.

1. Setting Up the Authentication Service
The Authentication Service is responsible for authenticating users and issuing JWT tokens.

Dependencies: Add the necessary dependencies to your pom.xml or build.gradle.
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version> 
Authentication Service: Handles user authentication and issues JWT tokens.
Other Microservices: Validate JWT tokens for each request using a filter.

kafka
=======
Apache Kafka
Apache Kafka is an open-source distributed event streaming platform used for building real-time data pipelines and streaming applications. 

Core Concepts
Producer: An application that sends messages to Kafka.
Consumer: An application that reads messages from Kafka.
Broker: A Kafka server that stores and serves data.
Topic: A category or feed name to which records are sent.
Partition: A division of a topic's data, allowing for parallel processing.
Offset: A unique identifier for each record within a partition.


How Kafka Works
Producers send records to a specific topic.
Brokers store these records in partitions.
Consumers subscribe to topics and read records from partitions.
Kafka Streams processes the data in real-time.

Example Use Cases
Log Aggregation: Collecting and aggregating log data from various sources.
Real-Time Analytics: Processing and analyzing data in real-time.
Event Sourcing: Storing state changes as a sequence of events.
Data Integration: Connecting different data systems for seamless data flow.


RabbitMQ is an open-source message broker software that facilitates the exchange of messages between different systems or applications.
 It is widely used for building scalable and reliable distributed systems.

Core Concepts
Producer: An application that sends messages to RabbitMQ.
Consumer: An application that receives messages from RabbitMQ.
Queue: A buffer that stores messages until they are consumed.
Exchange: Routes messages to queues based on routing rules.
Binding: A link between an exchange and a queue that defines how messages are routed.

How RabbitMQ Works
Producers send messages to an exchange.
Exchanges route messages to one or more queues based on routing keys and binding rules.
Consumers subscribe to queues and process the messages.
Example Use Cases
Task Queues: Distributing tasks among multiple workers.
Message Broadcasting: Sending messages to multiple consumers.
Request/Reply: Implementing RPC (Remote Procedure Call) patterns.



CACHING
===========
Caching is a technique used to store frequently accessed data in a high-speed storage layer,
 so that future requests for that data can be served faster than accessing the primary storage location. This improves performance and reduces latency.

Redis is a powerful in-memory data structure store, often used as a cache to improve the performance and scalability of applications.

Key Features of Redis Cache
In-Memory Storage: Redis stores data in memory, providing extremely fast read and write operations.
Data Structures: Supports various data structures like strings, hashes, lists, sets, sorted sets, bitmaps, hyperloglogs, and geospatial indexes.
Persistence: Offers options for persistence, allowing data to be saved to disk.
Replication: Supports master-slave replication for high availability.
Transactions: Provides support for transactions.
Pub/Sub: Includes publish/subscribe capabilities for messaging.
Lua Scripting: Allows execution of Lua scripts for complex operations.

Common Caching Patterns
Cache-Aside: The application first checks the cache for data. If the data is not found (cache miss), it retrieves the data from the database and stores it in the cache for future requests1.
Write-Through: Data is written to the cache and the database simultaneously. This ensures that the cache is always up-to-date1.
Write-Behind: Data is written to the cache first and asynchronously updated in the database. This improves write performance1.
Query Caching: Caches the results of database queries to speed up repeated querie 

CI/CD
==========
A CI/CD pipeline is an automated workflow that streamlines the software delivery process, integrating code changes, running tests, and 
deploying applications.
Key Components of a CI/CD Pipeline
Source Code Management
Version Control: Tools like Git are used to manage code changes and maintain a single source of truth1.
Build Automation
Build Tools: Tools like Maven or Gradle compile the code, package it, and prepare it for deployment2.

Automated Testing
Unit Tests: Verify individual components of the code.
Integration Tests: Ensure that different components work together.
End-to-End Tests: Simulate user scenarios to validate the entire application2.

Deployment Automation
Continuous Delivery: Automatically prepares code changes for release to production.
Continuous Deployment: Automatically deploys every change that passes automated tests to production1.
CI/CD Pipeline Stages
Commit Stage
Developers commit code changes to the version control system.
Automated tests run to validate the changes2.
Build Stage
The code is compiled and packaged.
Additional tests may be run to ensure the build is successful2.
Test Stage
Comprehensive testing is performed, including unit, integration, and end-to-end tests2.
Deploy Stage
The application is deployed to staging or production environments.
Automated deployment tools ensure consistent and reliable releases1.
Benefits of CI/CD Pipelines
Early Error Detection: Automated tests catch errors early in the development process2.
Faster Releases: Shorter release cycles enable quicker delivery of new features and bug fixes1.
Consistent Deployments: Automated processes reduce the risk of human error during deployment2.
Improved Collaboration: Teams can work simultaneously on different parts of the application, integrating changes frequently1.

Tools for CI/CD Pipelines
Jenkins: An open-source automation server that supports building, deploying, and automating projects1.
GitLab CI: Integrated CI/CD capabilities within GitLab1.
CircleCI: A cloud-based CI/CD tool that automates the build, test, and deployment process2.
Travis CI: A CI/CD service used to build and test projects hosted on GitHub

jenkin
=======
Jenkins is a popular open-source automation server used to automate various aspects of software development, including building, testing, and
deploying applications. Here are some key points about Jenkins:

Key Features of Jenkins
Extensibility: Jenkins supports hundreds of plugins that integrate with various tools in the CI/CD toolchain, making it highly extensible1.
Easy Installation: Jenkins is a self-contained Java-based program that can be easily installed on various operating systems, including Windows, Linux, and macOS1.
Web Interface: Jenkins provides a user-friendly web interface for configuration and management, including on-the-fly error checks and built-in help1.
Distributed Builds: Jenkins can distribute build and test loads across multiple machines, speeding up the CI/CD process1.
Pipeline as Code: Jenkins supports defining build pipelines as code using the Jenkinsfile, which allows for versioning and better management of the CI/CD pipelin
Basic Concepts

Jobs/Projects: The fundamental unit of work in Jenkins, which can be configured to perform various tasks like building code, running tests, and deploying applications.
Build Triggers: Mechanisms to start jobs, such as SCM changes, scheduled times, or manual triggers.
Nodes/Agents: Machines that Jenkins uses to execute jobs. The main Jenkins server is called the master, and additional machines are called agents.
Plugins: Extensions that add functionality to Jenkins, such as integration with version control systems, build tools, and deployment platforms.

Swagger
==========

hw to implement gatway API
synchronous and asynchronous communication
=============================================

### Synchronous Communication

**Synchronous communication** occurs when the sender and receiver are synchronized in time. 
This means that both parties are actively engaged in the communication process at the same time.

#### Characteristics:
- **Immediate Response**: The sender waits for the receiver to process the request and respond immediately.
- **Blocking**: The sender is blocked until the receiver completes the operation.
- **Examples**: 
  - **HTTP Requests**: Traditional web requests where the client waits for the server to respond.
  - **Function Calls**: In programming, a function call where the caller waits for the function to return a result.

### Asynchronous Communication

**Asynchronous communication** occurs when the sender and receiver do not need to be synchronized in time. 
The sender can continue processing other tasks while waiting for the receiver to respond.

#### Characteristics:
- **Non-blocking**: The sender does not wait for the receiver to complete the operation and can continue with other tasks.
- **Examples**: 
  - **Message Queues**: Systems like RabbitMQ or Kafka where messages are sent and processed independently.
  - **Promises/Futures**: In programming, constructs that allow operations to be performed asynchronously.

how we can handle exception in microservice if any service got fail .
====================================================================
1. Circuit Breaker Pattern
The Circuit Breaker pattern is used to detect failures and prevent the application from trying to perform an action that is likely to fail.
This helps in avoiding cascading failures and allows the system to recover gracefully.

Implementation: Libraries like Hystrix (by Netflix) or Resilience4j can be used to implement circuit breakers.
How it works: When a service call fails repeatedly, the circuit breaker trips and further calls to the failing service are prevented for a certain period. During this time, fallback logic can be executed.
2. Retry Pattern
The Retry pattern involves retrying a failed operation a certain number of times before giving up. This is useful for transient faults that may resolve
themselves after a short period.

Implementation: Libraries like Spring Retry or Resilience4j can be used to implement retry logic.
How it works: When a service call fails, the system waits for a specified interval before retrying the operation. The interval can be fixed or exponential backoff can be used.
3. Fallback Mechanism
Fallback mechanisms provide an alternative response when a service fails. This ensures that the system can still provide a response,
even if it is not the ideal one.

Implementation: Fallback methods can be defined in the service layer to return default values or cached data.
How it works: When a service call fails, the fallback method is invoked to provide an alternative response.
saga design pattern
=====================
In a microservices architecture, each service is responsible for its own domain logic and data.
When a business process involves multiple services, it can be challenging to ensure data consistency and integrity across all services.
 
# Solution
The Saga pattern solves this problem by introducing a central orchestrator, called the Saga,
which coordinates the execution of local transactions across multiple services.
 
*Key Components*
1. *Saga*: The central orchestrator that coordinates the execution of local transactions.
2. *Local Transactions*: Each service executes a local transaction, which can either succeed or fail.
3. *Compensating Actions*: If a local transaction fails, the Saga executes a compensating action to undo the effects of the failed transaction.
 
*How it Works*
1. The Saga receives a request to execute a business process.
2. The Saga breaks down the business process into a series of local transactions.
3. Each local transaction is executed by a corresponding service.
4. If a local transaction succeeds, the Saga proceeds to the next transaction.
5. If a local transaction fails, the Saga executes a compensating action to undo the effects of the failed transaction.
6. The Saga continues to execute local transactions and compensating actions until the business process is complete.

 
*Example*
Suppose we have an e-commerce application that involves multiple services:
 
1. *Order Service*: Responsible for creating and managing orders.
2. *Inventory Service*: Responsible for managing inventory levels.
3. *Payment Service*: Responsible for processing payments.
 
Git commands

Testing
=========
Junit 
1. Annotations:
• @Test: Marks a method as a test method.
• @BeforeEach: Runs before each test method to set up test data.
• @AfterEach: Runs after each test method to clean up test data.
• @BeforeAll: Runs once before all test methods in the class.
• @AfterAll: Runs once after all test methods in the class.
• @Disabled: Disables a test method.
2. Assertions:
• assertEquals(expected, actual): Checks if two values are equal.
• assertTrue(condition): Checks if a condition is true.
• assertFalse(condition): Checks if a condition is false.
• assertNotNull(object): Checks if an object is not null.
assertThrows(exceptionClass, executable): Checks if an exception is thrown.
Annotations


Mokito
======
	Mockito is a popular mocking framework for unit tests in Java. It allows you to create mock objects and define their behavior, making it easier to test your code in isolation. Here are some key features and concepts:
	Key Features
	1. Mock Creation: Create mock objects for interfaces and classes.
	2. Stubbing: Define the behavior of mock methods.
	3. Verification: Verify that certain methods were called on the mock objects.
	4. Annotations: Use annotations like @Mock, @Spy, @Captor, and @InjectMocks to simplify mock creation and injection.
	
	
	@Mock
	• Purpose: Creates a mock object for the specified class or interface.
	• Usage: Used to mock dependencies in your test class.
	• Example:
@Mock
private MyService myService;
	@Spy
	• Purpose: Creates a spy object, which is a partial mock. It allows you to call real methods while still being able to stub and verify interactions.
	• Usage: Used when you want to test real methods but also need to mock some behavior.
	• Example:
@Spy
private MyService myService = new MyService();
	@Captor
	• Purpose: Creates an ArgumentCaptor to capture arguments passed to mock methods.
	• Usage: Used to capture and verify the arguments passed to a method.
	• Example:
@Captor
private ArgumentCaptor<String> captor;
	@InjectMocks
	• Purpose: Injects mock objects into the tested object automatically.
	• Usage: Used to inject mocks into the object under test.
	• Example:
@InjectMocks
private MyController myController;

What is Mokito 
wht is diff b/w Mock and Spay and injectWork
Annotations


Coding 
========
java 8 featurs coding and syntaxes of all
java 8 based coding




 

 









