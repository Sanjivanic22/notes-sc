
core java questions and ans
==============================
1)Difference between final,finalize and finally
Can you explain the memory management in java and changes in java 8
JVm automatically manages the memory and its devided into into multiple
heap menmory,stack memory,method area and native memory

3)what are the oops principle 
Encapsulation 
abstraction 
diff b/w them

what is diff b/w encapsulation and abstractions
Aspect	     Encapsulation	                                                              Abstraction
Definition	Bundles data and methods into a class and restricts direct access to fields.	Hides implementation details and shows only essential features.
 Purpose	Protects internal data and controls access.	                          Simplifies complexity by focusing on what an object does.
  Focus         	Securing and controlling access to data.	                               Simplifying interaction by hiding details.
Implementation	Achieved using private fields and public getters/setters.              	Achieved using abstract classes, interfaces, and abstract methods.
Visibility	   Controlled via access modifiers (private, public, etc.).	                  Hides internal logic; user only sees relevant features.

Polymorphism 
Inheritance

what is diff b/w abstract and interface
Abstract Class
27. Definition: An abstract class is a class that cannot be instantiated and may contain abstract methods (methods without a body) as well as concrete methods (methods with a body).
28. Usage: Used to share common code among related classes.
29. Inheritance: A class can extend only one abstract class (single inheritance).
30. Members: Can have fields, constructors, and methods (both abstract and concrete).
31. Access Modifiers: Can use all access modifiers (public, protected, private).
nterface
32. Definition: An interface is a reference type that can contain only abstract methods (until Java 8, when default and static methods were introduced) and constants.
33. Usage: Used to define a contract that classes must follow.
34. Inheritance: A class can implement multiple interfaces (multiple inheritance).
35. Members: Can have abstract methods, default methods, static methods, and constants.
36. Access Modifiers: Methods are implicitly public and abstract; fields are implicitly public, static, and final.

Solid principle

can we overload static method?
Stringbuilder vs Stringbuffer
how we can handle concurrentmodificationException.
oncurrentModificationException occurs when a collection is modified while iterating over it using iterators, enhanced for-loops, or other methods 
that are not designed for concurrent modification. Here are some ways to handle or avoid this exception:
1. Using Iterator's remove Method
Instead of modifying the collection directly, use the remove method of the Iterator:
2. Using CopyOnWriteArrayList
For concurrent modifications, use thread-safe collections like CopyOnWriteArrayList:
Absolutely! CopyOnWriteArrayList is a thread-safe variant of ArrayList provided in the java.util.concurrent package. 
It is designed for use in concurrent environments where read operations 
are more frequent than write operations. Here are some key points about CopyOnWriteArrayList:

3. Using synchronized Block
Synchronize the block of code that modifies the collection:
4. Using Stream API
Use the Stream API to filter out elements and collect the result into a new list:

diff between Collection and stream.
Collections are used for storing and managing groups of elements.
Streams are used for processing sequences of elements in a functional style.

comparable vs comparator
Comparable:

Defines natural ordering within the class itself.
Only one compareTo method can be implemented per class.
Used when a single default sorting order is needed.
Comparator:

Defines custom ordering outside the class.
Multiple Comparator implementations can be created for different sorting criteria.
Used when multiple sorting orders are needed or when you cannot modify the class.
when we override equal method and hashcode
Custom Equality Logic: When you need to define custom logic for comparing objects based on specific attributes rather than their memory addresses.
Hash-Based Collections: When you plan to use your objects in hash-based collections, ensuring that objects considered equal have the same hash code.

why we use throw if exception can be handle usig try catch
Reasons to Use throw:
Propagating Exceptions: Sometimes, you might want to propagate an exception to a higher level in the call stack rather than handling it immediately. 
This allows the calling method to handle the exception or propagate it further.
Custom Exceptions: You can create and throw custom exceptions to signal specific error conditions in your application. 
This makes your code more readable and maintainable.
Separation of Concerns: By throwing exceptions, you can separate the logic of detecting errors from the logic of handling them. 
This can make your code cleaner and easier to understand.
Fail-Fast Principle: Throwing exceptions immediately when an error condition is detected can help you identify and fix issues early in the development process.


Collections
==============
1)what are the collections you used in your project 
List Set map
what is diff b/w araylist and linkedlist
internal working of Hashmap
Concurrent hashmap
what is diferance b/w hashmap and concurrent hashmap
how to handle Concurrecy in java
Handling concurrency in Java involves managing multiple threads to ensure that they operate correctly and efficiently without causing data inconsistencies
 or other issues. Here are some key concepts and tools for handling concurrency in Java:

1. Synchronized Methods and Blocks
Use the synchronized keyword to control access to critical sections of code, ensuring that only one thread can execute them at a time.

2. Locks
Java provides more flexible locking mechanisms through the java.util.concurrent.locks package, such as ReentrantLock.
3. Atomic Variables
Use atomic variables from the java.util.concurrent.atomic package for lock-free thread-safe operations on single variables.
4. Concurrent Collections
Java provides thread-safe collections in the java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, and BlockingQueue.
5. Executors and Thread Pools
Use the ExecutorService framework to manage a pool of threads, simplifying the process of managing thread lifecycles.

Multithreading 
================
how to implement Multthreading
Summary:
Extending Thread Class: Create a new thread by extending Thread and overriding run.
Implementing Runnable Interface: Implement Runnable and pass it to a Thread object.
Using ExecutorService: Manage a pool of threads with ExecutorService.
Synchronization: Use synchronization to avoid race conditions and ensure thread safety.

what is deadlock and Race constion and how to overcome?
A Deadlock is situation where two or more more threads are unbale to proceed because each is waiting for other to release resource.
*Example of Deadlock*
Suppose we have two threads, T1 and T2, and two resources, R1 and R2.
 
1. T1 locks R1 and waits for R2.
2. T2 locks R2 and waits for R1.
 
In this situation, both threads are waiting for each other to release resources, resulting in a deadlock.
# Race Condition
A race condition is a situation where the behavior of a program depends on the relative timing of threads.
 
*Example of Race Condition*
Suppose we have two threads, T1 and T2, that are incrementing a shared variable, x.
 
1. T1 reads the value of x (x = 0).
2. T2 reads the value of x (x = 0).
3. T1 increments the value of x (x = 1).
4. T2 increments the value of x (x = 1).
# Prevention Techniques
*Deadlock Prevention*
1. Avoid nested locks.
2. Use lock timeouts.
3. Establish a lock ordering mechanism.
 
*Race Condition Prevention*
1. Use synchronization mechanisms (e.g., locks, semaphores).
2. Use atomic operations.
3. Avoid shared variables.

1) What is submit and execute command do
	Submit Command:
	• Purpose: The submit method is used to submit a task for execution and returns a Future object. This Future can be used to retrieve the result of the computation, handle exceptions, and monitor the status of the task.
	
• Key Point: The submit method is useful when you need to get the result of the task or manage its execution

.
1. Execute Command:
• Purpose: The execute method is used to execute a task but does not return a Future. It is typically used for tasks that do not need to return a result or be monitored.

Key Point: The execute method is simpler and is used for tasks where you do not need to track the outcome
Which is better between Thread and Runnable and why
What is Reentrant Lock
Syncronization and class level lock and which method release the lock

java 8 features
=====================
wht are the features
Lambda Expressions: These allow you to write more concise and readable code by enabling functional programming.
Stream API: This provides a powerful way to process sequences of elements, making it easier to perform operations like filtering, mapping, and reducing.
Intermediate Operations
=============================
Intermediate operations return a new stream and are used to transform or filter the elements of the stream.
 These operations are lazy, meaning they do not process the elements until a terminal operation is invoked. 
Intermediate operations can be chained together to form a pipeline.

Common intermediate operations include:

filter: Filters elements based on a predicate.
map: Transforms each element using a function.
flatMap: Transforms each element into a stream and flattens the result.
distinct: Removes duplicate elements.
sorted: Sorts the elements.
peek: Performs an action on each element without modifying the stream.
Example:

List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A"))
    .map(String::toUpperCase)
    .collect(Collectors.toList());

Terminal Operations

Terminal operations produce a result or a side-effect and mark the end of the stream pipeline. 
Once a terminal operation is invoked, the stream is considered consumed and cannot be reused.

Common terminal operations include:

collect: Converts the stream into a collection or another data structure.
forEach: Performs an action for each element.
reduce: Combines elements to produce a single result.
count: Returns the number of elements in the stream.
anyMatch: Returns true if any element matches the given predicate.
allMatch: Returns true if all elements match the given predicate.
noneMatch: Returns true if no elements match the given predicate.
findFirst: Returns the first element in the stream.
findAny: Returns any element in the stream.
Example:

List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
long count = names.stream()
    .filter(name -> name.length() > 3)
    .count();

}
In this example, filter is an intermediate operation, and count is a terminal operation.
 The stream pipeline processes the elements only when the terminal operation count is invoked.

Default Methods: 
=================
Default methods are defined in interfaces using the default keyword.
They provide a default implementation that can be overridden by implementing classes.
Interfaces can now have default methods with implementations, allowing for more flexible and backward-compatible code.

Optional Class: This helps in handling null values more gracefully, reducing the risk of NullPointerException.

New Date and Time API: A comprehensive and modern API for date and time manipulation, replacing the old java.util.Date and java.util.Calendar.
Immutability: The new date and time classes are immutable and thread-safe.
Fluent API: Provides a fluent API for constructing and manipulating date and time objects.
Better Time Zone Support: Improved support for time zones and offsets.
Date and Time Arithmetic: Simplified date and time arithmetic operations.

Nashorn JavaScript Engine: A new engine for executing JavaScript code within Java applications.

Method References: These provide a way to refer to methods without invoking them, making code more readable and concise.
Type Annotations: These allow annotations to be used in more places, such as on generic types.

what is functional interface and examples 
A functional interface in Java is an interface that has exactly one abstract method. These interfaces are used primarily for lambda expressions and method references, 
enabling a more functional programming style in Java. Functional interfaces can have multiple default or static methods, but only one abstract method.
Key Points:
Single Abstract Method: A functional interface has exactly one abstract method.
Lambda Expressions: Functional interfaces are the target types for lambda expressions.
Annotation: The @FunctionalInterface annotation can be used to indicate that an interface is intended to be a functional interface, although it's not mandatory
Ex.Runnable ,callable and comparable 
1. Runnable Interface
The Runnable interface is a functional interface with a single abstract method run.
@FunctionalInterface
public interface Runnable {
    void run();
}
Example Usage:
Runnable runnable = () -> System.out.println("Running in a thread");
new Thread(runnable).start();

2. Comparator Interface
The Comparator interface is a functional interface with a single abstract method compare.

@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
Example Usage:
Comparator<String> comparator = (s1, s2) -> s1.compareTo(s2);
int result = comparator.compare("apple", "banana");
System.out.println("Comparison result: " + result);

Predefined functional interface
==================================
Java 8 introduced several predefined functional interfaces in the java.util.function package. These interfaces are designed to support functional programming and can be used with lambda expressions and method references.
1 .Predicate
1. Predicate
Represents a boolean-valued function of one argument.
Example:
import java.util.function.Predicate;
public class PredicateExample {
    public static void main(String[] args) {
        Predicate<String> isLongerThan5 = str -> str.length() > 5;
        System.out.println(isLongerThan5.test("Hello")); // Output: false
        System.out.println(isLongerThan5.test("Hello, world!")); // Output: true
    }

2. Function<T, R>
Represents a function that accepts one argument and produces a result.
Example:
import java.util.function.Function;
public class FunctionExample {
    public static void main(String[] args) {
        Function<String, Integer> stringLength = str -> str.length();
        System.out.println(stringLength.apply("Hello")); // Output: 5
    }
}
3. Consumer
Represents an operation that accepts a single input argument and returns no result.
Example:
import java.util.function.Consumer;
public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> print = str -> System.out.println(str);
        print.accept("Hello, world!"); // Output: Hello, world!
    }
}
4. Supplier
Represents a supplier of results.
Example:
import java.util.function.Supplier;
public class SupplierExample {
    public static void main(String[] args) {
        Supplier<String> supplier = () -> "Hello, world!";
        System.out.println(supplier.get()); // Output: Hello, world!
    }
}
5. UnaryOperator
Represents an operation on a single operand that produces a result of the same type as its operand.
Example:
import java.util.function.UnaryOperator;
public class UnaryOperatorExample {
    public static void main(String[] args) {
        UnaryOperator<Integer> square = x -> x * x;
        System.out.println(square.apply(5)); // Output: 25
    }
}
6. BinaryOperator
Represents an operation upon two operands of the same type, producing a result of the same type as the operands.
Example:
import java.util.function.BinaryOperator;
public class BinaryOperatorExample {
    public static void main(String[] args) {
        BinaryOperator<Integer> add = (a, b) -> a + b;
        System.out.println(add.apply(5, 3)); // Output: 8
    }
}

what is the diff b/w Runnable and Callable
Runnable: Used for tasks that do not need to return a result or handle checked exceptions.
Callable: Used for tasks that need to return a result or handle checked exceptions.
Runnable: Cannot throw checked exceptions.
Callable: Can throw checked exceptions.

why default method allowed in function interface.
Default methods in functional interfaces allow for backward compatibility, enhanced functionality, and flexibility in API design. 
They enable interfaces to evolve without breaking existing implementations and provide additional utility methods that can be used by all implementing classes.

how we can achieve muliple inheritance in java 8.
stream api find maximum salary of employee.


can we replace @service with @component and vise versa?
Yes 
	Spring:
===============
	- What’s Spring framework & advantages-done
	## Spring 
-=================
Spring is opensource lightweight framework 
Which is used to develop any kind of application
It is like framework of framework because it support vrious framework like struts and hibernate.
Spring framework comprise several modules such as IOC,AOP,springn core,spring mvc

Advantages
==========
Spring framework provides predefined libraries and templates
Spring framework privide loos coupling
Manages the dependancies injection and IOC automatically
Spring framwork very easy to  testing
Spring web framework is well design mvc framework which provide the greate alteranative to another ````framework like struts.

Spring container
===================
Spring container is at the core of the spring framework.
The container will creates the object,wire them together,configure them and manage their complete life cycle from creation till destruction.
the spring container uses DI to manage the componenets that make up an application.


IOC container and types
=========================
IOC container
======================
The IOC container is INVERSION of control which is responsible to instantiate, configure and assemble the objects. 
The IoC container gets informations from the XML file and works accordingly. 
The main tasks performed by IoC container are:
=>to instantiate the application class
=>to configure the object
=>to assemble the dependencies between the objects

There are two types of IoC containers. They are:
==================================================
1)BeanFactory
2)ApplicationContext

In the spring both BeanFactory and ApplicationContext are interfaces used for managing beans. 

Difference between BeanFactory and the ApplicationContext
==================================================================

Using BeanFactory
=====================

Xml beanfactory is implementation class to use the bean factory for that we need to create the instance of xmlbeanfactory.
 To use the BeanFactory, we need to create the instance of XmlBeanFactory class as given below:

Resource resource=new ClassPathResource("applicationContext.xml");  
BeanFactory factory=new XmlBeanFactory(resource); 
 
The constructor of XmlBeanFactory class receives the Resource object so we need to pass the resource object to create the object of BeanFactory.


Using ApplicationContext
=============================
the ApplicationContext interface is built on top of the BeanFactory interface. 
It adds some extra functionality than BeanFactory such as simple integration with Spring's AOP, message resource handling (for I18N), event propagation, application layer specific context (e.g. WebApplicationContext) for web application.
 So it is better to use ApplicationContext than BeanFactory.
The ClassPathXmlApplicationContext class is the implementation class of ApplicationContext interface.
 
We need to instantiate the ClassPathXmlApplicationContext class to use the ApplicationContext as given below:

ApplicationContext context =   
    new ClassPathXmlApplicationContext("applicationContext.xml"); 

The constructor of ClassPathXmlApplicationContext class receives string, so we can pass the name of the xml file to create the instance of ApplicationContext.

spring bean life cycle
==========================
spring bean life will start from the bean creation and end with bean destruction
init and destry methods are impiratant in spring bean life cycle which can configure in xml file with init-initailization and 
init-destruction .or programatically we can do with @ initailization and @disposable method

Spring bean life cycle is maintained by IOC Container

1. Container gets started.

2. Container creates the object of bean as per request.

3. Dependencies is created

4. Dependencies is injected

5. Destroyed when container closed.
Dependancy lookup
==================
in Dependancy lookup we will  get the resource after demand.

i) dependency lookup makes the code tightly coupled. If resource is changed, we need to perform a lot of modification in the code.
ii)Not easy for testing This approach creates a lot of problems while testing the application especially in black box testing.

Dependancy injection
======================
Depenancy injection is design pattern thet removes the dependancies  from the programming code so that it can be easy to test and manage the application.
Dependancy injection makes our code loosely coupled.

Constructor injection
=======================
Here Our Ioc container uses parameterised constructor to create the target bean class object.
In that process we inject the dependant class object to target class object.

The <constructor-args> tag is used for constructor injection.
Here we inject the 
Primitive and string based value
Dependant object
Collection values
If all properties of spring bean class are mandatory to participate in the injection then we 
Should go for constructor injection.

Settter injection
===========================
Here IOC container calls the setter of target class to assign dependant class object to target class object.
<property>tag used for setter injection
We can inject the 
Primitive an string -based values
Dependant object
Collection values

If we want to involve only our choice of propetries into the spring class the we should go for setter injection.


Spring bean scope
===================
In Spring, "scope" refers to the lifecycle of a bean, defining how long a bean instance should live and how it should be created and shared within 
the application context.
Spring provides several scopes to manage the lifecycle and visibility of beans. Here are the common bean scopes available in Spring:

Singletone
===========
If scope is set to singletone scope ,the spring IOC container creates exactly one instance of the object defined by that bean defination.
It is default scope if no scope is specified
IOC container creates only one oject for spring bean class nad reuses that object.

Prototype
=============
If scope is set to prototype ,the spring IOC container creates a new instance of the object.
 every time a resquest for that specific bean is mode as rule 
use the prototype scope for all state-full beans and singletom scope for stateless beans.
To define prototype ,you can set the  scope property to prototype in the bean configuration file.

Scope=Request (for http protocol)
================================
bean instance will created per http request
Scope="session"
Ioc container keeps spring bean class object as session attribute of web app env.
bean instance will be created per http session

Global session

Autowring
=============
Autowiring enable you to inject the object depndancy .it internally uses setter or constructor injection.
Autowiring work with object dependancy.

In object dependancy we need to call referance of another class from dependancy class manualy
But if we use the wiring concept then we need not to call the refernace maually from the dependant class.
Modes of autowiring
No
Default autowiring mode,its mean no autowiring by default.

Byname
--------
Inject the onject dependancy.according to proptery name and bean name.
In this case proptery name bean name must be same internally call setter method .

Bytype
---------
Inject the object dependancy according to type property name and bean name can be different.
Internally call setter method.

Constructor
------------
Inject by calling constructor of class calls constructor having the large no of parameter.
Autodected-deprecated.

Spring Transaction in spring
=============================
In spring transaction can be handle in two ways.
i.e Programatically and declaratively
1) in programatic we have to write series of code  to commit your transaction and rollback transaction.
that means we need to write for commit or rollback transaction
there is one more way that is declarative way where we write template in xml
whenever the is runtime exception the spring will automatically rollback the transaction and if there no exception then spring will commit the transaction.
Spring ORM
============
It is spring module providing abstraction on multiple ORM framework like hiberanate like 
O-r mapping 
The process of Linking Db tables with java classes and Db table cols with the properties of classes and having  Synchronization b/w them is called o-r mapping.

Spring ORM
It is a spring module providing abstraction on multiple ORM frameworks like hiberante,iBatis and etc to simplify Object based O-R mapping persistance logic.

It supplies mutiple templates classes like hibernate template 

How can we disable configuration in spring?
============================================
To disable auto-configuration for a specific class or feature in a Spring Boot application, you can use the @EnableAutoConfiguration annotation 
along with the exclude attribute. This allows you to exclude specific auto- configuration classes from being applied.

@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class, MultipartAutoConfiguration.class}}

public class YourApplication {

public static void main(String[] args) {

SpringApplication.run(YourApplication.class, args);

}
	
	
	- Difference between independent Singleton object & Spring Singleton Bean
	
Independent Singleton Object:
Definition: A Singleton object is a design pattern that ensures a class has only one instance and provides a global point of access to that instance.
Implementation: Typically implemented using a private constructor, a static instance variable, and a public static method to return the instance.
Lifecycle: The lifecycle of the Singleton object is managed manually by the developer. The instance is created when first accessed and remains in memory for the duration of the application.
Scope: The Singleton object is application-wide, meaning it is shared across the entire application.

Spring Singleton Bean:
Definition: A Spring Singleton Bean is a bean managed by the Spring container that is defined with a singleton scope. This means that only one instance of the bean is created and shared within the Spring container.
Implementation: Configured using Spring's XML configuration or annotations (@Bean, @Scope("singleton")).
Lifecycle: The lifecycle of the Singleton Bean is managed by the Spring container. The instance is created when the container is initialized and remains in memory for the duration of the container's lifecycle.
Scope: The Singleton Bean is container-wide, meaning it is shared within the Spring container but not necessarily across the entire application if multiple containers are used.
	- What's limitations of autowiring

can we use @compoenet in repository class and can we use @repository in component 
Yes, you can use @Component in a repository class and @Repository in a component class, but there are specific reasons and best practices for using each annotation.

@Component:
Generic Annotation: @Component is a generic stereotype annotation indicating that the class is a Spring-managed component.
Usage: It can be used on any Spring-managed bean, including service, repository, and controller classes.
@Repository:
Specialized Annotation: @Repository is a specialized stereotype annotation indicating that the class is a Data Access Object (DAO). 
It provides additional features such as exception translation.
Usage: It is typically used on classes that interact with the database, such as repository classes.
 
springboot
=======================
how to secure end point from URL using spring restful services
Securing endpoints in Spring RESTful services is crucial to protect your application from unauthorized access and potential security threats.
1. Use HTTPS
Ensure that your application uses HTTPS to encrypt communication between the client and server. This prevents data from being intercepted during transmission.

2. Spring Security Configuration
Extend the WebSecurityConfigurerAdapter class and override its methods to configure security settings.
3. Role-Based Access Control
Use role-based access control to limit access to sensitive resources based on user roles.
4. **JWT stateless authentication. This involves generating a token upon successful login and validating it for subsequent requests.

2)WHAT IS jwt HOW TO IMPLEMENT AND VALIDATE
What is JWT?
JSON Web Token (JWT) is an open standard (RFC 7519) for securely transmitting information between parties as a JSON object. 
It is commonly used for authentication and authorization in web applications. JWTs are compact, self-contained, and can be signed and optionally encrypted to ensure the integrity and confidentiality of the information they contain12.

Structure of JWT
A JWT consists of three parts:
Header: Contains metadata about the token, such as the type of token and the algorithm used for signing.
Payload: Contains the claims, which are statements about an entity (typically the user) and additional data.
Signature: Ensures the token hasn't been altered. It is created using the header, payload, and a secret key.

Implementing JWT
To implement JWT in a Spring Boot application, follow these steps:

1. Add Dependencies
Add the necessary dependencies to your pom.xml file:
<artifactId>jjwt</artifactId>
    <version>0.9.1</version>
2. Create JWT Utility Class
Create a utility class to generate and validate JWT tokens:
3. Configure Spring Security
Configure Spring Security to use JWT for authentication:
4. Create Authentication Filter
Create a filter to validate JWT tokens:
Validating JWT
To validate a JWT, you need to:

Extract Claims: Parse the token and extract the claims.
Verify Signature: Ensure the token's signature matches the expected signature using the secret key.
Check Expiration: Verify that the token has not expired.

6) What are the issues you faced in production and how you handled
8) caching, qualifiers, circular reference, annotations , REST APIs 
	what if build stucked when PR creating.
	what key mecanism will be used to secure external API server.

What’s repository in Spring Data JPA
In Spring Data JPA, a repository is a central interface that provides a way to perform CRUD (Create, Read, Update, Delete) operations on entities without the need to write boilerplate code. It abstracts the data access layer and allows you to interact with the database in a more convenient and consistent manner.

Key Points:
Interface-Based: Repositories are defined as interfaces, and Spring Data JPA provides the implementation at runtime.
CRUD Operations: They provide methods for basic CRUD operations and can be extended to include custom queries.
Query Methods: You can define query methods by simply declaring method signatures that follow a specific naming convention.
Common Repository Interfaces:
CrudRepository: Provides CRUD functionality.
Purpose: Provides basic CRUD (Create, Read, Update, Delete) operations.
Methods:
save(S entity): Saves a given entity.
findOne(ID id): Retrieves an entity by its ID.
findAll(): Returns all entities.
count(): Returns the count of entities.
delete(T entity): Deletes a given entity.
exists(ID id): Checks if an entity exists by its ID.
JpaRepository: Extends CrudRepository and PagingAndSortingRepository to provide additional JPA-specific methods.
flush(): Flushes all pending changes to the database.
saveAndFlush(S entity): Saves an entity and flushes changes immediately.
deleteInBatch(Iterable<T> entities): Deletes the given entities in a batch.

PagingAndSortingRepository: Adds methods for pagination and sorting.
findAll(): Returns all entities.
findAll(Sort sort): Returns all entities sorted by the given options.
findAll(Pageable pageable): Returns a paginated list of entities.

How we can use multiple database in the project
=====================================================
Using multiple databases in a Spring Boot project involves configuring multiple DataSource beans and setting up separate EntityManagerFactory 
and TransactionManager beans for each database. Here's a step-by-step guide to achieve this:

1. Add Dependencies
Ensure you have the necessary dependencies in your pom.xml file:
2. Configure DataSources
Define the configurations for each database in your application.properties or application.yml file.
3. Create Configuration Classes
Create separate configuration classes for each DataSource, EntityManagerFactory, and TransactionManager.
follow same process for secondary DB
4. Define Entity Classes and Repositories
Create entity classes and repositories for each database, ensuring they are in the correct packages.

What is AOP

Singleton, Factory and Abstract Factory Design pattern and where this Design pattern used in your project
==========================================================================================================

What is strong reference, Soft Reference., Weak Reference and Phantom Reference
How you can implement second level cache in your project

@GeneratedValue used for
The @GeneratedValue annotation in Java is used to specify how the primary key value should be generated for an entity. It is typically used in conjunction
with the @Id annotation in JPA (Java Persistence API) to mark a field as the primary key and to define the strategy for generating unique values for that key.
Key Points:
Purpose: Automatically generate unique primary key values for entity instances.
Strategies: Several strategies can be specified using the strategy attribute of the @GeneratedValue annotation.
Strategies:
AUTO: The persistence provider chooses the appropriate strategy for the database.
IDENTITY: The database generates the primary key value, typically using an auto-increment column.
SEQUENCE: Uses a database sequence to generate primary key values.
TABLE: Uses a table to generate primary key values.

 which HTTP method will be used for create and update at same time.
========================================================================
PUT: Used for both creating and updating a resource. It is idempotent and typically replaces the entire resource at the specified URI.

	@bean used for?
The @Bean annotation in Spring is used to indicate that a method produces a bean to be managed by the Spring container.
It is typically used in configuration classes to define beans that are created and managed by Spring's Inversion of Control (IoC) container.

Key Points:
Bean Definition: Methods annotated with @Bean define beans that are registered with the Spring container.
Configuration Classes: Commonly used within classes annotated with @Configuration.
Customization: Allows for the customization of bean creation and initialization.

	how we can get value from properties file in springboot.
=========================================================
using @Value 
using @cnfiguration propertis 
using environment object
hoe we can find out that code is 80% coverge in sonarcube.
what is the best authentication can be used to handle security in payment method based application.
=====================================================================================================
1. Multi-Factor Authentication (MFA)
MFA involves verifying the user's identity using two or more independent factors:

Knowledge: Something the user knows (e.g., password, PIN).
Possession: Something the user has (e.g., smartphone, hardware token).
Inherence: Something the user is (e.g., biometric data like fingerprints or facial recognition).
2. Biometric Authentication
Biometric authentication uses unique biological traits to verify identity. Common methods include:

Fingerprint Scanning
Facial Recognition
Iris Scanning
Biometric authentication is highly secure and user-friendly1.

3. Token-Based Authentication
Token-based authentication involves generating a unique token for each session. This token is used to verify the user's identity and can be implemented using:

Hardware Tokens: Physical devices that generate one-time passwords.
Software Tokens: Applications that generate one-time passwords.
4. SMS OTP (One-Time Password)
SMS OTP sends a one-time password to the user's mobile device via text message. While convenient, it is vulnerable to SIM interception and phishing attacks2.

5. Strong Customer Authentication (SCA)
SCA, mandated by the PSD2 regulation, requires at least two authentication factors from the categories mentioned above. It provides an additional layer of security for online payments1.

6. Encryption and Tokenization
Encrypting sensitive data and using tokenization to replace sensitive information with non-sensitive tokens can significantly enhance security3.

how we can hit external url from application.
=================================================
To hit an external URL from a Spring Boot application, you can use the RestTemplate or WebClient classes provided by Spring
Using RestTemplate
RestTemplate is a synchronous client to perform HTTP requests. It's simple to use but is being phased out in favor of WebClient.
Using WebClient
WebClient is part of the Spring WebFlux module and supports both synchronous and asynchronous operations. 
It's the recommended way to perform HTTP requests in Spring Boot applications.

if there is multiple restcontroller in one application then how system will address that which controller needs to be called.
================================================================================================================================
In a Spring Boot application with multiple @RestController classes, the system determines which controller to call based on the URL mapping defined in each
controller. 
Each @RestController class defines one or more request mappings using annotations like @RequestMapping, @GetMapping, @PostMapping, etc. These annotations 
specify the URL patterns that the controller methods handle.
URL Mapping: Each controller defines URL patterns using annotations.
Routing: The system routes requests to the appropriate controller based on the URL.
Path Variables and Request Parameters: Controllers can handle specific requests using path variables and request parameters.

What is spring boot & its architecture -done
	
	- What are the advantages of spring boot-done
	- What’s the disadvantage of Spring boot-done

	- What’s the important configuration file in Spring boot
	application.properties file or application.yml file

	- What is Spring Boot and What Are Its Main Features?-done

	- What Are the Differences Between Spring and Spring Boot?-done

What is Spring Initializr?

How to Disable a Specific Auto-Configuration?

What’s Actuator

 How to migrate existing project to Springboot?

	REST API:
==================
	- What is REST web services
	- What are HTTP methods supported by REST
	- What’s JAX-RS
	- What’s @RestController
	- Difference between SOAP & REST Webservices
	- What different output types supported by REST
	- How request payload from Client request gets mapped to @RequestBody object – Jackson library
	- Best practices for creating REST URI.
	- What’s @PathParameter
	- What’s are Idempotent methods
	- How to create/implement REST API
	- How to expose Restful webservice
	how to convert xml data into json


Annotations
============

database
=========
what is the diff b/w primary key,unique key and foreign key
whta is index how it works
what is diff b.w delet and truncate

Microservices
================
what is microservices
what is diff b/w monolithic and microservices
what is API gateway
hw to implement gatway API
Circuit breaker design pattern
what eureka server 
service dscovery 
service registry
load balancer
synchronous and asynchronous communication
hystrix
how we can handle exception in microservice if any service got fail .
saga design pattern
webclient 
feign client
admin server
Zipkin server
config server
security(JWT) 
redis
CI/CD jenkin

 Tools
========
Kafka 
Swagger

Git commands

Testing
=========
Junit 
Annotations


Mokito
======
What is Mokito 
wht is diff b/w Mock and Spay and injectWork
Annotations


Coding 
========
java 8 featurs coding and syntaxes of all
java 8 based coding




 

 









