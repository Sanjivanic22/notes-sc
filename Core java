## Core java concept
=======================
concurrentModificationEXaception
----------------------
A ConcurrentModificationException in Java is thrown when a collection (e.g., ArrayList, HashMap) is modified while being iterated over 
using methods like Iterator or enhanced for loop. This exception is typically encountered when you modify the collection directly 
(e.g., using add, remove, or put methods) during iteration.
7)concurrentModificatiobRxception
====================================
List <Integer> list=new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
list.add(4);
try{
Iterator <Integer> iterator=new Iterator<>();
Integer value=iterator.next();
while(iterator.hashNext){
if(value%2==0){
list.remove(list);
} }
catch(concurrentModificatiobRxception e){
Systrm.out.println("concurrentModificatiobRxception caugght"+e);
Sysout("list after modification attempt "+ list);

}

}


Java is Pass by Value or call by referance?
----------------------------------------------
Java is strictly "pass-by-value." When passing primitives, the actual value is copied. 
When passing objects, the reference to the object is copied (not the object itself), 
meaning the method gets a copy of the reference pointing to the same object. 
Key Points
Primitive Types: Passing a primitive type to a method results in passing a copy of the value. Changes to the parameter do not affect the original variable.
Object References: Passing an object to a method results in passing a copy of the reference. Changes to the object's state via the parameter reference 
affect the original object.

Java Architecture
===================
Java Architecture is a collection of components, i.e., JVM, JRE, and JDK. It integrates the process of interpretation and compilation. 
It defines all the processes involved in creating a Java program.
Java Architecture can be explained by using the following steps:
	• There is a process of compilation and interpretation in Java.
	• Java compiler converts the Java code into byte code.
	• After that, the JVM converts the byte code into machine code.
	• The machine code is then executed by the machine.

The Java architecture includes the three main components:
==========================================================
JDK(java development kit)
The JDK is a software package that contains everything you need for Java application development.
It includes the JRE, so it provides the runtime environment to execute Java applications.
It also includes development tools like the Java compiler (javac), debugger, profiler, and various utilities for creating, compiling, and debugging Java applications.
Developers use the JDK to write, compile, and test Java code.

JRE (Java Runtime Environment):
he JRE is a subset of the JDK.
It provides the runtime environment necessary to run compiled Java applications.
The JRE includes the Java Virtual Machine (JVM) and the runtime libraries required for executing Java applications.
End-users who only need to run Java applications use the JRE.

JVM (Java Virtual Machine):

The JVM is a virtual machine that executes Java bytecode.
It's responsible for loading Java classes, verifying them, and executing them.
The JVM abstracts the underlying hardware and operating system, allowing Java applications to be platform-independent.
It manages memory, performs garbage collection, and provides support for features like multithreading and exception handling.


OOP(Object oriented programming)
=====================================
Object-Oriented Programming is a methodology or paradigm to design a program using classes and objects. 
It simplifies software development and maintenance by providing some concepts:
object 
--------
An entity that has state and behavior is known as an object e.g., chair, bike, marker, pen, table, car, etc. It can be physical or logical (tangible and intangible).
The example of an intangible object is the banking system.

class
==========
Collection of objects is called class. It is a logical entity.

A class can also be defined as a blueprint from which you can create an individual object. Class doesn't consume any space.


Is_A relation(Inheritance)
============================
Inheritance represents the IS-A relationship which is also known as a parent-child relationship.
When one object acquires all the properties and behaviors of a parent object, it is known as inheritance. 
It provides code reusability. It is used to achieve runtime polymorphism
 .
 When you inherit from an existing class, you can reuse methods and fields of the parent class.

• By using extends keyword  we can implements is-a relationship
• For r Method Overriding (so runtime polymorphism can be achieved).

 there can be three types of inheritance in java:
single inheritance
-----------------
When a class inherits another class, it is known as a single inheritance. 
multilevel 
When there is a chain of inheritance, it is known as multilevel inheritance.
hierarchical.
-------------------
When two or more classes inherits a single class, it is known as hierarchical inheritance.

multiple and hybrid inheritance is supported through interface only.

why multiple inheritance is supported by the java
----------------------------------------------------------
To reduce the complexity and simplify the language, multiple inheritance is not supported in java.
Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. 
If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

Has_A relationship
==================
If a class have an entity reference, it is known as Aggregation. Aggregation represents HAS-A relationship.
For code reusability we use the Aggregation.
Has-A relationship is also known as composition or aggregation. 
There is not specific keyword for has-relationship the mostly use keyword is new keyword.

The main disadvantage of has a relationship is it increases dependancy b/w classes and creates maitainance problem.

Composition vs aggregation
===========================
Composition
--------------
In case of composition whenever container object is destroyed contained object will be destroyed automatically .i.e without exixting container object there is not chance of existing contained object 
i.e container and contained object having strong association 
Ex. Usniversity is composed or several departments 
Wenever we are closing university all departments will closed.the relation b/w usniversity object & department object is strong association is nothing but compsition.

Aggregation
-------------
In case of aggregation whenever container object is destroyed there is gurranty of destruction of contained object .i.e without exixting container object  there may be chnace of existing  contained object 
i.e container object just maintains referances of contained object
This relationship is called  weakassociation which is nothibng but aggregation.

Ex.several profecers will work in th department
Wherver we are closing the department still there may be a chance of existing professors.this relationship b/w department is nothing but aggegation..

Composition is stronger tha aggregation,in short ,a relationship b/w two object is refered as associtaion ,nd an association is known as composition when object owns another
 while association is known as agrregation wen object uses another object.

POLymorphism
===================
Polymorphism in Java is a concept by which we can perform a single action in different ways.
 So polymorphism means many forms.
There are two types of polymorphism in Java: 
compile-time polymorphism and runtime polymorphism. We can perform polymorphism in java by method overloading and method overriding.
Overloading
===============
Two methods are said to be overloaded if method names are same but argument as different is called oveloading
public class Calculator {
    // Overloaded method to add two integers
    public int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Overloaded method to add two double values
    public double add(double a, double b) {
        return a + b;
    }
}

Overriding
==============
If methdo names and arhuments must be matched  i.e method signature must be matched is called overriding.
class Animal {
    // Method to be overridden
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    // Overriding the sound method
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();  // Animal reference, Animal object
        Animal myDog = new Dog();        // Animal reference, Dog object

        myAnimal.sound();  // Calls Animal's sound method
        myDog.sound();     // Calls Dog's sound method (overridden method)
    }
}


Abstraction
==================

Abstraction
Abstraction is a process of hiding the implementation details and showing only functionality to the user.

There are two ways to achieve abstraction in java
Abstract class (0 to 100%)
Interface (100%)
Diff b/w abstrcat class and interface
======================================
In Java, both abstract classes and interfaces are used to define abstract types that specify what a class must do, but not how it does it.
However, they serve different purposes and have distinct characteristics.

1. Purpose
Abstract Class: Used to represent a base class that other classes can inherit from. It can provide some default behavior (implemented methods) while leaving 
some methods abstract for subclasses to implement.
Interface: Used to represent a contract that a class must adhere to. It’s purely about defining the behavior that implementing classes must provide,
without providing any implementation (until Java 8 introduced default methods).
2. Syntax
Abstract Class: Declared with the abstract keyword. It can have both abstract methods (without implementation) and concrete methods (with implementation).

abstract class Animal {
    abstract void sound(); // Abstract method
    void eat() { // Concrete method
        System.out.println("This animal eats");
    }
}
Interface: Declared with the interface keyword. It can have abstract methods , default methods (with implementation, introduced in Java 8), and static methods.
interface Animal {
    void sound(); // Abstract method
    default void eat() { // Default method (Java 8+)
        System.out.println("This animal eats");
    }
}
3. Method Implementation
Abstract Class: Can have both abstract and concrete methods. Subclasses can inherit and use the concrete methods or override them.
Interface: Prior to Java 8, all methods were implicitly abstract. From Java 8 onward, interfaces can have default and static methods with implementations.
4. Inheritance
Abstract Class: A class can inherit from only one abstract class (single inheritance).
Interface: A class can implement multiple interfaces (multiple inheritance of type).
5. Fields/Variables
Abstract Class: Can have instance variables (fields) and can define methods to manipulate these variables.

Interface: Can only have public, static, and final variables (essentially constants). Instance variables are not allowed.
abstract class Animal {
    int age; // Instance variable
}

interface Animal {
    int AGE = 10; // Constant (implicitly public, static, and final)
}
6. Constructors
Abstract Class: Can have constructors. These constructors are called when a subclass is instantiated.
Interface: Cannot have constructors because interfaces cannot be instantiated.
7. Access Modifiers
Abstract Class: Can have methods with any access modifier (public, protected, private, or default).
Interface: Methods are implicitly public. From Java 9 onward, private methods are allowed within interfaces to share code between default methods.
8. When to Use
Abstract Class:
Use when classes share a common base of code (fields or methods).
Use when you want to provide some common functionality that can be inherited by subclasses.
Use when you expect future classes to have many common methods or fields.
Interface:
Use to define a contract that multiple classes can implement.
Use when you want to achieve multiple inheritance in Java.
Use when you want to provide flexibility for unrelated classes to implement the same set of behaviors.
9. Example Use Cases
Abstract Class: A Vehicle abstract class where all vehicles have common properties (like speed, fuel) and behaviors (like startEngine()), but startEngine() may be implemented differently in subclasses (Car, Bike).

Interface: A Flyable interface for classes that can fly (Bird, Airplane), where each class implements its own version of the fly() method.

Marker interface
==================
An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, random access method.etc.
They are used to provide some essential information to the JVM so that JVM may perform some useful operation.
If an interface wont contains any method & by implementing that interface if our object will get ability such type of interface are called marker interface.

By implementing seriazable interface we can send object across the n/w and we can save state of object to a file this extra ability is provided through seriazable interface

By implemeting clonable interface our object will be in position to provide exactly duplicate object

As marker interface interface wont contain method them jvm is responsible for that to reduce complexity of program
We can create our own marker interfface but customization of jvm required


Encapsulation
==============
Encasulating data and corresponding method into ingle module is called encapsulation
Datahiding+abstraction

Encapsulation in Java is a process of wrapping code and data together into a single unit, for example, a capsule which is mixed of several medicines.

It is a way to achieve data hiding in Java because other class will not be able to access the data through the private data members.

The encapsulate class is easy to test. So, it is better for unit testing.

Ex.in world java the class is unit where instance variable and instance methods declared or wrapping in single unit as class which is nothing but encapsulation.

Fail-Fast and FailSafe
============================
Fail-Fast systems abort operation as-fast-as-possible exposing failures immediately and stopping the whole operation. 
Whereas, Fail-Safe systems don't abort an operation in the case of a failure. Such systems try to avoid raising failures as much as possible.

Collection
==============
If we want to represent Group of individual object as single entity then we should go for collection.
Java collection can achieve all the operation that you perform on a data such as searching ,sorting ,insertion and deletion and manipulation.

List 
=====
If we want to represent group of individual object where insertion order is preserved and duplicates are allowed then we should go for list interface.
Lis interface found in java.util package and inherits the Collection interface.
The implementation classes of List interface are ArrayList, LinkedList, Stack and Vector. The ArrayList and LinkedList are widely used in Java programming. 

ArrayList
===========
Java ArrayList class uses a dynamic array for storing the elements. It is like an array, but there is no size limit. We can add or remove elements anytime.

• Java ArrayList class can contain duplicate elements.
• Java ArrayList class maintains insertion order.
• Java ArrayList class is non synchronized Java ArrayList imlements  random access interface,so that we can access element with same speed. Heance if our frequesnt operation 
is retrivval operation then best datastructure is arraylist.
• But if our frequesnt operation operation is inserstion or deletion in the middle then arraylist is worst choice because it required several shift operators.

• linkedList
===============
Java LinkedList class uses a doubly linked list to store the elements. It provides a linked-list data structure.

• Java LinkedList class can contain duplicate elements.
• Java LinkedList class maintains insertion order.
• Java LinkedList class is non synchronized.
• In Java LinkedList class, manipulation is fast because no shifting needs to occur.
•  if our frequesnt operation operation is inserstion or deletion in the middle then the best datastructure is linkedlist .
• if our frequesnt operation  is retrivval operation then linkedlist is not good choice.

Set
=====
If we want to represent group of ndividual object where duplicates are not allowed.
Thhe implentation classes of the set is hashset and linkedhashset.

Hashset
========
Java HashSet class is used to create a collection that uses a hash table for storage. It inherits the AbstractSet class and implements Set interface.

• HashSet stores the elements by using a mechanism called hashing.
• HashSet contains unique elements only.
• HashSet allows null value.
• HashSet class is non synchronized.
• HashSet doesn't maintain the insertion order. Here, elements are inserted on the basis of their hashcode.
• HashSet is the best approach for search operations.
• The initial default capacity of HashSet is 16, and the load factor is 0.75.

Linkedhashset
===============
Java LinkedHashSet class is a Hashtable and Linked list implementation of the Set interface. It inherits the HashSet class and implements the Set interface.
Java LinkedHashSet class contains unique elements only like HashSet.
• Java LinkedHashSet class provides all optional set operations and permits null elements.
• Java LinkedHashSet class is non-synchronized.
• Java LinkedHashSet class maintains insertion order.

Tree set
=========
Java TreeSet class implements the Set interface that uses a tree for storage. It inherits AbstractSet class and implements the NavigableSet interface. The objects of the TreeSet class are stored in ascending order.
• Java TreeSet class contains unique elements only like HashSet.
• Java TreeSet class access and retrieval times are quiet fast.
• Java TreeSet class doesn't allow null element.
• Java TreeSet class is non synchronized.
• Java TreeSet class maintains ascending order.

Map
====
A map contains values on the basis of key, i.e. key and value pair. Each key and value pair is known as an entry. A Map contains unique keys.
A Map is useful if you have to search, update or delete elements on the basis of a key.
There are two interfaces for implementing Map in java: Map and SortedMap, and three classes: HashMap, LinkedHashMap, and TreeMap
A Map doesn't allow duplicate keys, but you can have duplicate values. HashMap and LinkedHashMap allow null keys and values, but TreeMap doesn't allow any null key or value.
A Map can't be traversed, so you need to convert it into Set using keySet() or entrySet() method.

Hashmap
==========
Java HashMap class implements the Map interface which allows us to store key and value pair, where keys should be unique.
If you try to insert the duplicate key, it will replace the element of the corresponding key. 
It is easy to perform operations using the key index like updation, deletion, etc. HashMap class is found in the java.util package.

• Java HashMap contains values based on the key.
• Java HashMap contains only unique keys.
• Java HashMap may have one null key and multiple null values.
• Java HashMap is non synchronized.
• Java HashMap maintains no order.
• The initial default capacity of Java HashMap class is 16 with a load factor of 0.75

linkedHashMap
==============
Java LinkedHashMap class is Hashtable and Linked list implementation of the Map interface, with predictable iteration order. 
It inherits HashMap class and implements the Map interface.

• Java LinkedHashMap contains values based on the key.
• Java LinkedHashMap contains unique elements.
• Java LinkedHashMap may have one null key and multiple null values.
• Java LinkedHashMap is non synchronized.
• Java LinkedHashMap maintains insertion order.
• The initial default capacity of Java HashMap class is 16 with a load factor of 0.75.

TreeMap
==========

Java TreeMap class is a red-black tree based implementation. It provides an efficient means of storing key-value pairs in sorted order.
• Java TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
• Java TreeMap contains only unique elements.
• Java TreeMap cannot have a null key but can have multiple null values.
• Java TreeMap is non synchronized.
• Java TreeMap maintains ascending order.

ConcurrentHashMap
===================
• ConcurrentHashMap is an enhancement of Hashmap as we know that while dealing with threads in our application HashMap is not good choice 
because performace wise hashmp is not upto the mark.

• Underlaying data structure for Concurrenthashmap is hashtable

• Concurrenthashmap is thread safe

• At a time any no of thread are applicable for a read operation without locking the Concurrenthashmap object which is not there in hashmap

• In Concurrenthashmap the object is divided into number of segments according to concurrency level
• concurrency level Concurrenthashmap is 16.
• In Concurrenthashmap,at a time any number of threads can perform retrival operation but for updated in the object, 
the thread must lock the perticular segment in which the thread wants  to operate  this is called segment locking or bucket locking
• inserting null object is not possible in concurrenthashmap as key or value.

• Comparable interface
==========================
comparable interface is use for default natural sorting order.
Java Comparable interface is used to order the objects of the user-defined class.
This interface is found in java.lang package and contains only one method named compareTo(Object). 
It provides a single sorting sequence only, i.e., you can sort the elements on the basis of single data member only

compareTo(Object obj) method
public int compareTo(Object obj): It is used to compare the current object with the specified object. It returns
	• positive integer, if the current object is greater than the specified object.
	• negative integer, if the current object is less than the specified object.
	• zero, if the current object is equal to the specified object.

Comparator
========================
java caomparatir interface use for customize sorting order
Java Comparator interface is used to order the objects of a user-defined class.
This interface is found in java.util package and contains 2 methods compare(Object obj1,Object obj2) and equals(Object element).
It provides multiple sorting sequences, i.e., you can sort the elements on the basis of any data member, for example, rollno, name, age or anything else.

dif b/w comparable and comparator
---------------------------------------
1) Comparable provides a single sorting sequence. In other words, we can sort the collection on the basis of a single element such as id, name, and price
.The Comparator provides multiple sorting sequences. In other words, we can sort the collection on the basis of multiple elements such as id, name, and price etc.
2) Comparable affects the original class, i.e., the actual class is modified.	
 Comparator doesn't affect the original class, i.e., the actual class is not modified.
3) Comparable provides compareTo() method to sort elements.	
 Comparator provides compare() method to sort elements.
4) Comparable is present in java.lang package.	
 A Comparator is present in the java.util package.
5) We can sort the list elements of Comparable type by Collections.sort(List) method.	
We can sort the list elements of Comparator type by Collections.sort(List, Comparator) method
6)We can use comparable to define defualt natural sorting.
We can use copmarator to define customized sorting order.

Multithreading
===============
What is multi threading
Multithreading in Java is a process of executing multiple threads simultaneously.
Java Multithreading is mostly used in games, animation, etc.

Advantages
=============
1) It doesn't block the user because threads are independent and you can perform multiple operations at the same time.
2) You can perform many operations together, so it saves time.
3) Threads are independent, so it doesn't affect other threads if an exception occurs in a single thread.

Thread
=======
A thread is a lightweight subprocess, the smallest unit of processing. It is a separate path of execution.


Thread scheduller
===================
A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java.

Ways to define instantiate & start a new  thread
We can define thread in two ways
1)By extending thread class
2)By implemeting runnable interface.

Which best apporoach
=====================
Among he two ways of defining a thread implements runnable mechanism is recommended to use.
In the first approach our class always extending thread class& hence there is chance of extending any other class but 
in the second approach we can extends some other class also while implementing runnable interface hence 2nd approach is recommended to use.

Thread priority
=================
• Every thread in java has some priority but the range of thread priority is 1 to 10(1 is least and 10 is highest)
• Thread.MIN_priority--1
• Thread.NORM_priority--5
• Thread.Max_priority--10
• Thread scheduler use this priority while allocation cpu 
• The thread which is having highest priority will get chance first.
• If two threads having same priority then we cant expect exact excution order it depends on thread scheduler
• Default priority of main  thread is 5


 How to prevent excecution of thread
===========================================
• We can prevent thread from execution by using methods  
• Yeild 
----------
• Yield () method causes to pause current executing thread for giving chance to reamaing waiting threads of same priority.
• If there are no waiting threads or all waiting threads have low priority then the same thread will continue its excution once again.
• Public void native yield()

Join
---------
If  thread want to wait until completing some other thread then we should go for join() method
Whenever we are using join () we should compulsary handle the inturrupted exception.either by try catch or thows  otherwise we will get compiletime error.

Sleep
======
If thread don’t want to perform any operation for perticular amount of time then we should go for sleep()
Whenever we are using sleep () we should compulsary handle the inturrupted exception.either by try catch or thows  otherwise we will get compiletime error.

Sychronization
================
• Synchronized is the modifier applicable only for methods and blocks& we cant apply for classes and variables.
if a method or block declared as synchronized then at a time only one thread is allowed to execute that method or block on the given object.
• The main advantages of sychronized keyword is it can resolve the inconsistancy problem
• The main linitation of synchronized keyword is it increses waiting time of  threads & effect the performance of the system.
• Hence if there is no requirement then its never recommended to use sychronized keyword.

Syschronized block
===================
• If very few lines of code requires sycronization then it is never recommended to declare the entire method as sychronized .we have to declrae entire methods as sysnchronized .we have to declare those few lines of code inside sychronized block.
• The main advantages of sychronized block over sychronized method is it reduces the waiting time of thread and improves the performance of the system.

Inter thread communicatiion methods.
Two thread will communicate with other by using Wait ,Notify ,NitifyAll
• The thread which requires updation it has to call wait() method.the thread which is responsible to update  it has to call notify methods
• We can call wait () ,notify and notifyAll() methods only from sychronized area otherwise we will get runtime exception. Saying IllgalMonitorStateException.

• If thread calls wait() method it releases lock immediately and entred into the waiting state.the releases lock of only current object but not all locks. 
After calling notify and notifyAll() methods thread releases the lock but nt immediately. 
Except these wait(),notify,notifyAll() there is no other case where thread release lock.

• Notify vs NotifyAll()
==========================
• We can use notify() to  only one waiting thread but which waiting thread will be notified we cant expect eaxclty.All remaining thread have to wait for further notifications.
• But in case of notifyALL() all waiting threads will be notifying but the thread will be excecuted one by one.

Deadlock&startvation
=====================
• If two thread are waiting for each other forever.such type of situation is called Deadlock
• There is no resolution technoque but  but several prevention techniques are possible.
• Sychronized keyword is the only reseaon for deadlock hence while using sychronized keyword we have to take very much care.

• A long  waiting thread which ends at certain point of time is called starvation.

Daemon threads
===============
• The threads which are waiting in the ackground are called daemon thread
• Ex.garbage collector.
• The main objective of daemon threads is to provide support for non daemon threds.
• We can check whether thread is daemon or not by using isDaemon() method.
• Main thread is always non daemon &its not possible to change its daemon nature

Thread life cycle
===================
1. New state
Definition: When a thread is created, it is in the new state. It remains in this state until the start() method is called.

Example:
Thread thread = new Thread(new RunnableTask()); // Thread is in NEW state

2. Runnable
Definition: When the start() method is called on a thread, it moves to the runnable state. In this state, the thread is eligible to run by the JVM, but it is not running yet. 
The actual running of the thread depends on the thread scheduler.

Example:
thread.start(); // Thread moves to RUNNABLE state

3. Blocked
Definition: A thread enters the blocked state when it is waiting for a monitor lock to enter a synchronized block/method.

Example:
synchronized (lock) {
    // Critical section
}
If a thread tries to enter this synchronized block and the lock is already held by another thread, it will move to the blocked state.

4. Waiting
Definition: A thread enters the waiting state when it is waiting indefinitely for another thread to perform a particular action (e.g., waiting on an object's monitor with Object.wait()).

Example:
synchronized (lock) {
    lock.wait(); // Thread enters WAITING state
}
5. Timed Waiting
Definition: A thread enters the timed waiting state when it is waiting for another thread to perform a specific action within a stipulated time.
This can happen with methods like Thread.sleep(), Object.wait(long timeout), Thread.join(long millis), etc.

Example:
Thread.sleep(1000); // Thread enters TIMED_WAITING state
6. Terminated
Definition: A thread enters the terminated state once its run() method completes or when it is explicitly terminated (e.g., by an uncaught exception).

Example:
class RunnableTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

Thread thread = new Thread(new RunnableTask());
thread.start(); // Thread runs and completes
// Now the thread is in TERMINATED state

How to kill thread
====================
A thread can stop or kill another thread by using stop() method then automatically running thread enterd into dead state.
it is deprecated method and not recommended to to use.

Suspending &resuming thread.
=============================
A thread can suspend another thread by using susped()method
A thread can resume a suspended thread by using resume().method.

String handling
==================
Object class
The most common method which are required for any java object are encapsulated into saperate class which is nothing but objct class.sun people made this class as parent for all java classess so that its method are bydefault available to every java class automatically.
Every class in java is child class of object either directly or indirectly.if ur class wont exends any other class then only our class is direct child class of object.


Why string is immutable in java
=================================
The String is immutable in Java because of the security, synchronization and concurrency, caching, and class loading. 
The reason of making string final is to destroy the immutability and to not allow others to extend it.

The String objects are cached in the String pool, and it makes the String immutable. 
The cached String literals are accessed by multiple clients. So, there is always a risk, where action performs by one client affects all other clients. 
For example, if one client performs an action and changes the string value from Pressure to PRESSURE, all remaining clients will also read that value. For the performance reason, caching of String objects was important, so to remove that risk, we have to make the String Immutable.


To String
============
We can use this method to find string representation of an object.

Hashcode
==========
For every object jvm will assign one unique id which is nothing but hashcode.
Jvm uses hashcode will saving object into hashcode or hashset or hashmap.
Based on our requirement we can generate hashcode by overriding hashcode method in our class.

Equals()
---------
We can use  equals method to check equality of two objects.

Diff b/w ==operator and .equals method
========================================
== operator is always meant for referance comparision where as .equls() meant for content comparision.

== operator is applicable for both premitives and object referance
In case of  object referance == opeartor is always meant for referance comparation i.e
If two referance pointing to the same object then only ==operator returns true.

.equals()
It is method applicable for only for object referance but not for primitives
By default .equals method present in object class I also meant for referance comparasion only
We cant override .equlas method for content comparation.

Immutable 
============
Once we created a string object we cant perform any changes in the existing object ,if are trying to perform any changes with those changes new object will be created.this behaviour is nothing but immutability of the string object.

Mutable
========
Once we crrated a string buffer object we can perform any changes in the existing object.this behavoiur is nothing but mutability of stringbuffer object

StringBuffer
=============
If the content will changes frequently it is never recommended to go for string beacause for every change compulsory new object will created to
handle this cumpolsary we should go for stringbuffer where changes will be performed in existing object  only instead of creating new object.

Stringbuilder
================
Evry method present in stringbuffer is sychronized.hence at atime only one thread is allowed to access stringbuffer object it incfeases the waiting time of thread  &effects performance of the system.
To resolve this problem we should go for stringbuilder.
Stringbuilder is same as stringbuffer but sstringbuffer is synchronized and thread safe and stringbuilder is not synchronized.
Stringbuffer performance is low and stringbuilder performance is high.

String vs stringbuffer and stringbuilder
==========================================
If the content will not change frequently then we should go for String 
If content will change frequently and thread safety required then go for String buffer
If content will change frequently and thread safety is not required then go for stringbuilder.

Wrapper classes
================
The main objective of wrapper classes are
1)to wrap primitive into object form so that we can handle primitive just like object
To define several utility methods for premitives

Creating Wrapper Objects:

Integer integerObject = new Integer(10); // Deprecated in Java 9, use valueOf instead
Integer integerObject = Integer.valueOf(10); // Preferred way
Boolean booleanObject = Boolean.valueOf(true);
Character characterObject = Character.valueOf('a');

Auto boxing 
==============
Automatic conversion of primitive value to the wrapper object by compiler is called Autoboxing

 Autounboxing
===============
Auttomatic conversion of wrapper object to the primitive type by compiler is called Auto unboxing
// Autoboxing
int primitiveInt = 50;
Integer wrappedInt = primitiveInt; // Compiler automatically boxes the int

// Auto-unboxing
Integer integerObject = 100;
int unboxedInt = integerObject; // Compiler automatically unboxes the Integer

Excepintion handling
=====================
Exception 
When unwanted ,unexpected event that distrupt the normal low of program is called exception.

Checked exception
-----------------------
Checked exceptions are exceptions that are checked at compile-time by the Java compiler for smooth execution.
If a method throws a checked exception, it must either handle the exception using a try-catch block or 
declare the exception using the throws keyword in the method signature. If neither is done, the code will not compile.
Examples:
IOException
SQLException
FileNotFoundException
ClassNotFoundException

Key Characteristics:
Must be explicitly handled or declared.
Represents conditions that a reasonable application might want to catch (e.g., file not found, network issues).
public class CheckedExceptionExample {
    public static void main(String[] args) {
        try {
            File file = new File("nonexistentfile.txt");
            FileInputStream fis = new FileInputStream(file);
        } catch (IOException e) {
            System.out.println("Caught IOException: " + e.getMessage());
        }
    }
}
Unchecked exception
--------------------
Unchecked exceptions are exceptions that are not checked at compile-time. 
They are subclasses of RuntimeException and can occur during the execution of the program. Since the compiler does not check them, 
it’s not mandatory to catch or declare them.
Examples:
NullPointerException
ArrayIndexOutOfBoundsException
ArithmeticException
IllegalArgumentException

Key Characteristics:
Not required to be caught or declared.
Represents programming errors, such as logic flaws or improper use of an API.

When to Use Which?
Checked Exceptions: Use them for conditions that are beyond the control of the program, such as file handling or network errors. 
They force the developer to think about and handle potential issues.

Unchecked Exceptions: Use them for programming errors where it's not feasible to recover, such as null pointer access, or for situations where
the exception is more about a bug in the code rather than a recoverable situation.
ex
int[] numbers= {1,2,3};
	System.out.println(numbers[2]);

Custom exception
-------------------
To meet programing requirement some times we have create our own exception is known as custom exception.
In Java, you can create your own exceptions by extending the Exception class (for checked exceptions) or the RuntimeException class (for unchecked exceptions). 
Custom exceptions are useful for creating meaningful and domain-specific error handling.
Ex.TooOldException,Insufficient balance
Steps to Create a Custom Exception:
Create a Class: Extend Exception or RuntimeException.
Add Constructors: Include constructors that match the standard exception constructors,
e.g., a no-argument constructor, a constructor that takes a message, and one that takes a message and a cause.

Compiletime error 
====================
A compile-time error in Java occurs when the Java compiler detects an issue in your code that prevents it from being successfully compiled into bytecode.
These errors are typically related to syntax, type checking, and the rules of the Java language.
Because they are detected during the compilation phase, your program won't run until these errors are fixed.

Runtime error
==================
 runtime error in Java occurs while the program is running, after successful compilation. These errors are typically due to issues that only manifest 
during the execution of the program, such as invalid user input, resource unavailability, or logical errors that lead to exceptions. 
Unlike compile-time errors, runtime errors are not caught by the compiler and can cause the program to terminate unexpectedly if not handled properly.
Try 
----
To maintain the risky code
Catch
--------
To maintain handling code
Final
-------
We can use final keyword with method ,variable and classess.
If we decalre class as final then we cant create the child class. 
If we declare the varibale as final then reassignment of variable is not possible.
If declare the method as final the method overriding is not possible.

Finally 
---------
It is block associated with try -catch To maitain the clean up code which should be  always executed  irrespective of whether exception raised or not 
and exception handled or not.such type place is nothing but finally block.finally will executed then return will be excuted.
	• 
Finalize
--------------
It is method which should excuted by garbage collector before destroying the  any object to perform cleanup activities.

Throw
---------
The main purpose of throw keyword is to handover iur created exception manually to the jvm.
Sometimes we can create exception object maunally & handover that object to the JVM explicitly by using throw keyword.
We can use throw keyword for customized exceptions.

Throws
----------
The main purpose of throws keyword is to delegate the responsibity of exception handling to the caller methods in case of checked exception ,
to convince compiler.

Exception propagation
---------------------
The process of delegating the responsibility of exception handling from one method to another method by using throws keywords us called exception propogation.


Serialization and deserialization
======================================
Serialization in Java is the process of converting an object into a byte stream, thereby making it possible to save the object to a file or transmit it 
over a network. This byte stream can later be deserialized back into a copy of the original object. Serialization is commonly used in Java for various
purposes such as saving an object’s state, deep copying objects, and transferring objects between Java programs over a network.
	1. Serializable Interface:
		○ An object can be serialized only if its class implements the java.io.Serializable interface. This interface is a marker interface (an interface with no methods) and serves to indicate that a class is eligible for serialization.
	2. ObjectOutputStream and ObjectInputStream:
		○ ObjectOutputStream: Used to write serialized objects to an output stream.
		○ ObjectInputStream: Used to read serialized objects from an input stream.
	3. Transient Keyword:
		○ Fields marked with the transient keyword are not included in the serialization process. This is useful for fields that you don't want to serialize, such as sensitive data (passwords) or system resources (file handles).
	4. serialVersionUID:
		○ A unique identifier for each class, serialVersionUID is used during deserialization to verify that the sender and receiver of a serialized object have loaded classes that are compatible with respect to serialization.
		○ If no serialVersionUID is declared, the JVM will automatically generate one at runtime, which may lead to unexpected InvalidClassException if the class definition changes.

Deserialization
--------------------
Byte stream is converted into an object.
Serialization and deserialization is plateform independent,it means you can serialize an object on one plateform and deserialize it on a different plateform.

clasLoader
-----------------
The Java ClassLoader is a part of the Java Runtime Environment that dynamically loads Java classes into the Java Virtual Machine. 
The Java run time system does not need to know about files and file systems because of classloaders.
Java classes aren’t loaded into memory all at once, 
but when required by an application. At this point, the Java ClassLoader is called by the JRE and these ClassLoaders load classes into memory dynamically.


(7) what is the diff b/w  collection and collections
Definition: Collection is an interface in the Java Collections Framework. It is the root interface of the collection hierarchy.

Definition: Collections is a utility class in the java.util package. It provides static methods that operate on or return collections.
 
(1) Can you explain your authentication & authorization flow in your application."

Authentication Flow
====================
User Registration:

Input: User provides registration details (e.g., username, password, email).
Process: Application validates the input, hashes the password using a secure algorithm (e.g., bcrypt, Argon2), and stores the user details in the database.
Output: Confirmation of successful registration or error messages if validation fails.

User Login:

Input: User provides login credentials (username and password).
Process:
The application retrieves the user details from the database using the provided username.
The hashed password from the database is compared with the hash of the provided password.
If the credentials are valid, a session or token (e.g., JWT - JSON Web Token) is generated.
Output:
For session-based authentication: A session ID is created and stored on the server, and a session cookie is sent to the client.
For token-based authentication: A JWT is generated, signed, and sent to the client.
Token Management:

Access Token: A short-lived token used for authentication and typically includes user identity and claims.
Refresh Token: A longer-lived token used to obtain a new access token without re-authenticating the user.


Authorization Flow
=======================

User Roles and Permissions:

Roles: Define a set of permissions. For example, roles like Admin, User, and Guest.
Permissions: Specific actions that a role can perform. For example, read, write, delete, update.
Access Control:

Input: An authenticated user's request to access a resource.
Process:
The application extracts the token from the request headers.
The token is validated and decoded to extract user identity and roles.
The requested resource and action are checked against the user's roles and permissions.
Output: Access is granted or denied based on the user's permissions.
Example Authentication & Authorization Flow Using JWT
User Registration:

User submits registration form.
Application hashes the password and saves user details in the database.
User Login:

User submits login form.
Application verifies credentials.
Application generates a JWT with user details and roles, signs it, and returns it to the client.
Token Storage:

Client stores the JWT (e.g., in local storage or a secure cookie).
Protected Resource Request:

Client includes JWT in the Authorization header (e.g., Authorization: Bearer <token>) of the request.
Server middleware/filters extract and validate the JWT.
Server decodes the token to extract user identity and roles.
Server checks if the user has the necessary permissions to access the resource.
If authorized, the server processes the request and returns the appropriate response.
Token Refresh:

Client sends refresh token request when the access token is about to expire.
Server validates the refresh token.
If valid, server issues a new access token and optionally a new refresh token.


10) Hashmap & Hashtable?
===============================
Key Differences:
Thread Safety:

HashMap: Not synchronized and not thread-safe. If multiple threads access a HashMap concurrently, and at least one of the threads modifies it structurally,
it must be externally synchronized.
Hashtable: Synchronized and thread-safe. Every method in Hashtable is synchronized, making it safe for use by multiple threads.

Null Keys and Values:

HashMap: Allows one null key and multiple null values.
Hashtable: Does not allow any null key or null value.
Performance:

HashMap: Generally faster since it is not synchronized and has less overhead.
Hashtable: Slower due to synchronization overhead.
Legacy:

HashMap: Part of the Java Collections Framework and introduced in Java 1.2.
Hashtable: A legacy class from Java 1.0, retrofitted to implement the Map interface.
Iterators:

HashMap: The iterators are fail-fast, meaning they will throw a ConcurrentModificationException if the map is structurally modified after the iterator is created.
Hashtable: The enumerators are not fail-fast.
Initial Capacity and Load Factor:

HashMap: Provides control over initial capacity and load factor.
Hashtable: Has default initial capacity of 11 and load factor of 0.75, but does not provide as much flexibility as HashMap.


12)How we can convert hashmap to a Synchronized,

To convert a HashMap to a synchronized (thread-safe) version in Java, you can use the Collections.synchronizedMap method. 
This method returns a synchronized (thread-safe) map backed by the specified map.

13)Is Hashmap maintained the order of dada?

No, HashMap does not maintain the order of data. 
In a HashMap, the order of the entries is not guaranteed. The entries are stored in a hash table, and their order can change as the HashMap is resized or when entries are added or removed.


14)diff bw/ treemap and linkedhashmap map?
TreeMap
===========

Ordering:

A TreeMap stores entries in a sorted order based on the natural ordering of its keys or according to a specified comparator.
The keys are sorted either in ascending order by default or in a custom order defined by a Comparator.

Implementation:

TreeMap is implemented using a Red-Black Tree, a type of self-balancing binary search tree.

Performance:

Operations like put, get, remove, and containsKey have a time complexity of O(log n) due to the underlying tree structure.

Null Keys:

TreeMap does not allow null keys, as null cannot be compared to other keys.

Use Case:

Use TreeMap when you need to maintain keys in a sorted order and when the performance of sorted operations is crucial.

LinkedHashMap
====================

Ordering:

A LinkedHashMap maintains the order of insertion. This means entries are returned in the order in which they were inserted.
It also has an option for access-order, which can be used to order entries based on their access time.

Implementation:

LinkedHashMap is implemented using a combination of a hash table and a doubly-linked list. Each entry maintains a reference to the previous and next entry, thus maintaining a doubly-linked list.

Performance:

Operations like put, get, remove, and containsKey have a time complexity of O(1) on average due to the underlying hash table structure.

Null Keys and Values:

LinkedHashMap allows one null key and multiple null values.

Use Case:

Use LinkedHashMap when you need to maintain the order of elements based on their insertion or access order and when fast iteration is required.
GENERiCS
=============
Generics is powerful feature that allows you to write flexible, reusable, and type-safe code. By using generics, you can define classes, interfaces, and methods with type parameters,
enabling them to operate on various data types while providing compile-time type checking.

Why Use Generics?
Type Safety: Generics allow you to catch type-related errors at compile time, rather than at runtime, reducing the likelihood of ClassCastException.
Reusability: Generics enable you to create classes, interfaces, and methods that work with different data types, making your code more flexible and reusable.
Elimination of Type Casting: With generics, you don't need to cast objects when retrieving them from a collection, as the type is already known.

